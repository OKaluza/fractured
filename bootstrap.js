var default_sources = {"include/glsl-header.frag":"//GLSL specific header\nprecision highp float;\n#define GLSL\n\n#define WEBGL_MAIN void main() {\n#define WEBCL_MAIN \n\n#define set_result(c) gl_FragColor = c;\n#define __OVERLOADABLE__ \n#define real float\n#define complex vec2\n#define rgba vec4\n\n//Palette lookup mu = [0,1]\n#define gradient(mu) texture2D(palette, vec2(mu, 0.0))\n\n//Uniform data\nuniform complex offset;\nuniform bool julia;\nuniform bool perturb;\nuniform real pixelsize;\nuniform complex dims;\nuniform complex origin;\nuniform complex selected;\nuniform sampler2D palette;\nuniform rgba background;\n\n//Current complex coordinate\nvarying complex coord;\n\n//GLSL only maths library prototypes\nreal __OVERLOADABLE__ log10(in real r);\nreal __OVERLOADABLE__ trunc(in real x);\nreal __OVERLOADABLE__ round(in real x);\nreal __OVERLOADABLE__ cosh(in real x);\nreal __OVERLOADABLE__ tanh(in real x);\nreal __OVERLOADABLE__ sinh(in real x);\nreal __OVERLOADABLE__ acosh(in real x);\nreal __OVERLOADABLE__ atanh(in real x);\nreal __OVERLOADABLE__ asinh(in real x);\ncomplex __OVERLOADABLE__ round(in complex z);\ncomplex __OVERLOADABLE__ trunc(in complex z);\n\n","include/opencl-header.cl":"//OpenCL specific header \n//(also need to search & replace all casts type() with c-style cast (type)() complex/real/rgba/int\n#ifdef FP64\n//Double precision\n#pragma OPENCL EXTENSION cl_khr_fp64: enable\n#define real double\n#define complex double2\n#else\n//Single precision\n#define real float\n#define complex float2\n#endif\n\n#define OPENCL\n#define rgba float4\n#define in const\n#define discard return (rgba)(0)\n\n//Functions with alternate names\n#define mod(a,b) fmod((real)a,(real)b)\n#define abs(a) fabs(a)\n#define atan(a,b) atan2(a,b)\n\n//Palette lookup mu = [0,1]\n__constant const sampler_t sampler = CLK_NORMALIZED_COORDS_TRUE | CLK_ADDRESS_REPEAT | CLK_FILTER_NEAREST;\n#define gradient(mu) read_palette(palette, mu)\nrgba read_palette(image2d_t palette, float mu)\n{\n  uint4 p = read_imageui(palette, sampler, (float2)(mu, 0.0));\n  return (rgba)(p.x/255.0, p.y/255.0, p.z/255.0, p.w/255.0); \n}\n\n#define WEBGL_MAIN \n#define WEBCL_MAIN rgba calcpixel(complex coord, complex offset, bool julia, bool perturb, real pixelsize, complex dims, complex origin, complex selected, image2d_t palette, rgba background) {\n\n#define set_result(c) return c;\nmain_function();  //Prototype\n\n//Input data\ntypedef struct __attribute__ ((packed)) Input\n{\n  real zoom;\n  real rotation;\n\n  real pixelsize;\n  complex origin;\n  complex selected;\n  rgba background;\n\n  uchar antialias;\n  uchar julia;\n  uchar perturb;\n\n  int width;\n  int height;\n} Input;\n\ncomplex rotate2d(complex v, real angle)\n{\n  const real Cos = cos(radians(angle));\n  const real Sin = sin(radians(angle));\n  return (complex)(v.x * Cos - v.y * Sin, v.x * Sin + v.y * Cos);\n}\n\n//Converts a set of pixel coords relative to element into\n// a new fractal pos based on current fractal origin, zoom & rotate...\ncomplex convert(int2 pos, int2 size, real zoom, real rotation)\n{\n   real half_w = size.x * 0.5;\n   real half_h = size.y * 0.5;\n\n   //Scale based on smallest dimension and aspect ratio\n   real box = size.x < size.y ? size.x : size.y;\n   real scalex = size.x / box;\n   real scaley = size.y / box;\n\n   real re = scalex * (pos.x - half_w) / (half_w * zoom);\n   real im = scaley * (pos.y - half_h) / (half_h * zoom);\n\n   //Apply rotation to selected point\n   return rotate2d((complex)(re, im), -rotation);\n}\n\n__kernel void fractured(__global struct Input* input, read_only image2d_t palette, write_only image2d_t output)\n{\n  int2 pos = (int2)(get_global_id(0), get_global_id(1));\n  int2 size = (int2)(input->width, input->height);\n  complex dims = (complex)(input->width, input->height);\n  complex coord = input->origin + convert(pos, size, input->zoom, input->rotation);\n\n  //Draw and blend in multiple passes for anti-aliasing\n  rgba pixel = (rgba)(0);\n  for (int j=0; j<input->antialias; j++) {\n    for (int k=0; k<input->antialias; k++) {\n      complex offset = (complex)((real)j/(real)input->antialias-0.5, (real)k/(real)input->antialias-0.5);\n      pixel += calcpixel(coord, offset, input->julia, input->perturb, input->pixelsize, \n                         dims, input->origin, input->selected, palette, input->background);\n    }\n  }\n  float aa = (float)input->antialias*(float)input->antialias;\n  pixel /= (rgba)(aa);\n  //pixel.x /= aa;\n  //pixel.y /= aa;\n  //pixel.z /= aa;\n  //pixel.w /= aa;\n  //rgba pixel = calcpixel(coord, input->antialias, input->julia, input->perturb, input->pixelsize, \n  //                       dims, input->origin, input->selected, palette, input->background);\n  write_imageui(output, (int2)(pos.x, pos.y), (uint4)(255*pixel.x,255*pixel.y,255*pixel.z,255*pixel.w));\n}\n\n","include/complex-header.frag":"//Maths library prototypes\n#define _C(x) complex(real(x),0.0)\n#define _CI(x) complex(0.0,real(x))\n#define _I complex(0.0,1.0)\n#define ident(args) args\n#define zero(args) 0\n#define czero(args) complex(0.0,0.0)\n\n#define PI  real(3.141592654)\n#define E   real(2.718281828)\nreal __OVERLOADABLE__ inv(in real r);\nreal __OVERLOADABLE__ neg(in real x);\nreal __OVERLOADABLE__ sqr(in real x);\nreal __OVERLOADABLE__ cube(in real x);\n//Complex number functions\nreal __OVERLOADABLE__ manhattan(in complex z);\nreal __OVERLOADABLE__ norm(in complex z);\nreal __OVERLOADABLE__ cabs(in real x);\nreal __OVERLOADABLE__ cabs(in complex z);\nreal __OVERLOADABLE__ arg(in complex z);\nreal __OVERLOADABLE__ imag(in complex z);\nbool __OVERLOADABLE__ equals(complex z1, complex z2, real tolerance);\ncomplex __OVERLOADABLE__ add(in complex a, in complex b);\ncomplex __OVERLOADABLE__ add(in real a, in complex b);\ncomplex __OVERLOADABLE__ add(in complex a, in real b);\ncomplex __OVERLOADABLE__ add(in real a, in real b);\ncomplex __OVERLOADABLE__ sub(in complex a, in complex b);\ncomplex __OVERLOADABLE__ sub(in real a, in complex b);\ncomplex __OVERLOADABLE__ sub(in complex a, in real b);\ncomplex __OVERLOADABLE__ sub(in real a, in real b);\ncomplex __OVERLOADABLE__ mul(in complex a, in complex b);\ncomplex __OVERLOADABLE__ mul(in real a, in complex b);\ncomplex __OVERLOADABLE__ mul(in complex a, in real b);\ncomplex __OVERLOADABLE__ mul(in real a, in real b);\ncomplex __OVERLOADABLE__ div (in complex z, in complex w);\ncomplex __OVERLOADABLE__ div(in real a, in complex b);\ncomplex __OVERLOADABLE__ div(in complex a, in real b);\ncomplex __OVERLOADABLE__ div(in real a, in real b);\ncomplex __OVERLOADABLE__ inv(in complex z);\ncomplex __OVERLOADABLE__ cpow(in real base, in real exponent);\ncomplex __OVERLOADABLE__ cpow(in real base, in complex exponent);\ncomplex __OVERLOADABLE__ cpow(in complex base, in real exponent);\ncomplex __OVERLOADABLE__ cpow(in complex base, in complex exponent);\ncomplex __OVERLOADABLE__ loge(in real r);\ncomplex __OVERLOADABLE__ loge(in complex z);\ncomplex __OVERLOADABLE__ log10(in complex z);\ncomplex __OVERLOADABLE__ cexp(in complex z);\ncomplex __OVERLOADABLE__ csin(in complex z);\ncomplex __OVERLOADABLE__ ccos(in complex z);\ncomplex __OVERLOADABLE__ ctan(in complex z);\ncomplex __OVERLOADABLE__ casin(in complex z);\ncomplex __OVERLOADABLE__ cacos(in complex z);\ncomplex __OVERLOADABLE__ catan(in complex z);\ncomplex __OVERLOADABLE__ csinh(in complex z);\ncomplex __OVERLOADABLE__ ccosh(in complex z);\ncomplex __OVERLOADABLE__ ctanh(in complex z);\ncomplex __OVERLOADABLE__ casinh(in complex z);\ncomplex __OVERLOADABLE__ cacosh(in complex z);\ncomplex __OVERLOADABLE__ catanh(in complex z);\ncomplex __OVERLOADABLE__ csqrt(in complex z);\ncomplex __OVERLOADABLE__ neg(in complex z);\ncomplex __OVERLOADABLE__ conj(in complex z);\ncomplex __OVERLOADABLE__ polar(in real r, in real theta);\ncomplex __OVERLOADABLE__ flip(in complex z);\ncomplex __OVERLOADABLE__ sqr(in complex z);\ncomplex __OVERLOADABLE__ cube(in complex z);\n\n\n","include/fractal-shader.frag":"WEBCL_MAIN\n\n---DATA---\n\nWEBGL_MAIN\n\n  //Globals\n  complex z, c;\n  complex point;            //Current point coord\n  complex z_1;              //Value of z(n-1)\n  complex z_2;              //Value of z(n-2)\n  int count = 0;            //Step counter\n  bool escaped, converged;  //Bailout flags\n\n  int limit = iterations;   //Max iterations\n  rgba colour = rgba(0.0,0.0,0.0,0.0);\n\n  //Init fractal\n  point = coord + complex(offset.x*pixelsize, offset.y*pixelsize);\n\n  ---INIT---\n\n  if (julia)\n  {\n    //Julia set default\n    z = point;\n    c = selected;\n  }\n  else\n  {\n    //Mandelbrot set default\n    if (perturb) \n      z = selected; //Perturbation\n    else\n      z = (0,0);\n    c = point;\n  }\n  z_1 = z_2 = (0,0);\n\n  //Formula specific reset...\n  ---RESET---\n\n  //Iterate the fractal formula\n  //(Loop counter can only be compared to constant in GL ES 2.0)\n  for (int i=0; i < iterations; i++)\n  {\n    //Second iterations check: \"limit\" can be overridden to cut short iterations,\n    //\"iterations\" must be a constant because of lame OpenGL ES 2.0 limitations on loops\n    if (i == limit) break;\n\n    //Update z(n-2)\n    z_2 = z_1;\n    //Save current z value for z(n-1)\n    z_1 = z;\n\n    //Run next calc step\n    count = i+1;  //Current step count\n    ---PRE_TRANSFORM---\n    ---ZNEXT---\n    ---POST_TRANSFORM---\n\n    //Check bailout conditions\n    escaped = true;\n    ---ESCAPED---\n    escaped = false;\n    converged = true;\n    ---CONVERGED---\n    converged = false;\n\n    //Colour calcs...\n    ---COLOUR_CALC---\n  }\n\n  if (escaped || converged)\n  {\n    //Outside colour: normalised colour index [0,1]\n    ---OUTSIDE_COLOUR---\n  }\n  else\n  {\n    //Inside colour: normalised colour index [0,1]\n    ---INSIDE_COLOUR---\n  }\n\n  set_result(colour);\n}\n\n","include/complex-math.frag":"//Maths functions\nreal __OVERLOADABLE__ inv(in real r)  {return 1.0/r;}\nreal __OVERLOADABLE__ neg(in real x)  {return -x;}\nreal __OVERLOADABLE__ sqr(in real x)  {return x*x;}\nreal __OVERLOADABLE__ cube(in real x) {return x*x*x;}\n\nbool __OVERLOADABLE__ equals(in complex z1, in complex z2, real tolerance)\n{\n  return distance(z1, z2) <= abs(tolerance);\n}\n\nreal __OVERLOADABLE__ manhattan(in complex z)\n{\n  return abs(z.x) + abs(z.y);\n}\n\nreal __OVERLOADABLE__ norm(in complex z)\n{\n  return dot(z,z);\n}\n\nreal __OVERLOADABLE__ cabs(in real x) {return abs(x);}\n\nreal __OVERLOADABLE__ cabs(in complex z)\n{\n  return length(z);\n}\n\nreal __OVERLOADABLE__ arg(in complex z)\n{\n  return atan(z.y,z.x);\n}\n\nreal __OVERLOADABLE__ imag(in complex z)\n{\n  return z.y;\n}\n\n#ifdef GLSL\n//Functions only required for GLSL, predefined in OpenCL\nreal __OVERLOADABLE__ log10(in real r)\n{\n  return log(r) / log(10.0);\n}\n\n//Hacks for opera to fix faulty recursive call detection\n#define RROUND(x) real(int(x + (x < 0.0 ? -0.5 : 0.5)))\n#define RTRUNC(x) real(int(x))\n\nreal __OVERLOADABLE__ trunc(in real x)\n{\n  return RTRUNC(x);\n  //return real(int(x));\n}\n\nreal __OVERLOADABLE__ round(in real x)\n{\n  return RROUND(x);\n  //return real(int(x + (x < 0.0 ? -0.5 : 0.5)));\n}\n\ncomplex __OVERLOADABLE__ round(in complex z)\n{\n  return complex(RROUND(z.x), RROUND(z.y));\n}\n\ncomplex __OVERLOADABLE__ trunc(in complex z)\n{\n  return complex(RTRUNC(z.x), RTRUNC(z.y));\n}\n\n// Hyperbolic Sine (e^x - e^-x) / 2\nreal __OVERLOADABLE__ sinh(in real x)\n{\n  real tmp = exp(x);\n  return 0.5 * (tmp - 1.0 / tmp);\n}\n\n/// Hyperbolic Cosine (e^x + e^-x) / 2\nreal __OVERLOADABLE__ cosh(in real x)\n{\n  real tmp = exp(x);\n  return 0.5 * (tmp + 1.0 / tmp);\n}\n\n// Hyperbolic Tangent (sinh / cosh)\nreal __OVERLOADABLE__ tanh(in real x)\n{\n  real tmp = exp(x);\n  real invtmp = 1.0 / tmp;\n  return (tmp - invtmp) / (tmp + invtmp);\n}\n\n// Hyperbolic arc sine log(x+sqrt(1+x^2))\nreal __OVERLOADABLE__ asinh(in real x)\n{\n  return log(x + sqrt(1.0+x*x));\n}\n\n// Hyperbolic arc cosine 2log(sqrt((x+1)/2) + sqrt((x-1)/2))\nreal __OVERLOADABLE__ acosh(in real x)\n{\n  return 2.0 * log(sqrt(0.5*x+0.5) + sqrt(0.5*x-0.5));\n}\n\n// Hyperbolic arc tangent (log (1+x) - log (1-x))/2 \nreal __OVERLOADABLE__ atanh(in real x)\n{\n  return (log(1.0+x) - log(1.0-x)) / 2.0;\n}\n#endif\n\ncomplex __OVERLOADABLE__ add(in complex a, in complex b) {return a + b;}\ncomplex __OVERLOADABLE__ add(in real a, in complex b) {return _C(a) + b;}\ncomplex __OVERLOADABLE__ add(in complex a, in real b) {return a + _C(b);}\ncomplex __OVERLOADABLE__ add(in real a, in real b)    {return _C(a + b);}\ncomplex __OVERLOADABLE__ sub(in complex a, in complex b) {return a - b;}\ncomplex __OVERLOADABLE__ sub(in real a, in complex b) {return _C(a) - b;}\ncomplex __OVERLOADABLE__ sub(in complex a, in real b) {return a - _C(b);}\ncomplex __OVERLOADABLE__ sub(in real a, in real b)    {return _C(a - b);}\n\ncomplex __OVERLOADABLE__ mul(in complex a, in complex b)\n{\n  return complex(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);\n}\n\ncomplex __OVERLOADABLE__ mul(in real a, in complex b) {return a * b;}\ncomplex __OVERLOADABLE__ mul(in complex a, in real b) {return a * b;}\ncomplex __OVERLOADABLE__ mul(in real a, in real b) {return _C(a * b);}\n\ncomplex __OVERLOADABLE__ div(in complex z, in complex w)\n{\n  //real conj = w.x*w.x + w.y*w.y;\n  //complex res = complex(z.x*w.x + z.y*w.y, z.y*w.x - z.x*w.y);\n  //return res / conj;\n  return complex(dot(z,w), z.y*w.x - z.x*w.y) / dot(w,w);\n}\n\ncomplex __OVERLOADABLE__ div(in real a, in complex z) //{return div(_C(a), z);}\n{\n  return complex(a*z.x, -a*z.y) / dot(z,z);\n}\n\ncomplex __OVERLOADABLE__ div(in complex z, in real a) //{return div(z, _C(a));}\n{\n  return complex(z.x*a, z.y*a) / (a*a);\n}\n\ncomplex __OVERLOADABLE__ div(in real a, in real b)    {return _C(a / b);}\n\ncomplex __OVERLOADABLE__ inv(in complex z)\n{\n  //1.0 / z\n  //return complex(z.x, -z.y) / dot(z,z);\n  return conj(z) / norm(z);\n}\n\ncomplex __OVERLOADABLE__ loge(in complex z)\n{\n  return complex(log(cabs(z)), arg(z));\n}\n\ncomplex __OVERLOADABLE__ log10(in complex z)\n{\n  return loge(z) / loge(_C(10));\n}\n\ncomplex __OVERLOADABLE__ loge(in real r)\n{\n  if (r < 0.0)\n    return complex(log(-r), PI);\n  else\n    return complex(log(r), 0.0);\n}\n\ncomplex __OVERLOADABLE__ neg(in complex z)\n{\n  return z * real(-1);\n}\n\ncomplex __OVERLOADABLE__ conj(in complex z)\n{\n  return complex(z.x, -z.y);\n}\n\ncomplex __OVERLOADABLE__ polar(in real r, in real theta)\n{\n  if (r < 0.0)\n  {\n    return complex(r * cos(mod(theta+PI, real(2.0*PI))), -r * sin(theta));    \n  }\n  return complex(r * cos(theta), r * sin(mod(theta, real(2.0*PI))));\n}\n\ncomplex __OVERLOADABLE__ cpow(in real base, in real exponent)\n{\n  return _C(pow(base, exponent));\n}\n\ncomplex __OVERLOADABLE__ cpow(in real base, in complex exponent)\n{\n  if (base == 0.0) return _C(0);\n  if (exponent.y == 0.0) return _C(pow(base, exponent.x));\n\n  real re = log(abs(base));\n  real im = atan(0.0, base);\n\n  real re2 = (re*exponent.x) - (im*exponent.y);\n  real im2 = (re*exponent.y) + (im*exponent.x);\n\n  real scalar =  exp(re2);\n\n  return  complex(scalar * cos(im2), scalar * sin(im2));\n}\n\ncomplex __OVERLOADABLE__ cpow(in complex base, in real exponent) \n{\n  if (base.x == 0.0 && base.y == 0.0) return _C(0);\n  if (exponent == 0.0) return _C(1);\n  if (exponent == 1.0) return base;\n  if (exponent == 2.0) return mul(base,base);\n  if (exponent == 3.0) return mul(mul(base,base),base);\n  if (base.y == 0.0) return _C(pow(base.x, exponent));\n  \n  real re = exponent * log(cabs(base));\n  real im = exponent * arg(base);\n\n  real scalar = exp(re);\n\n  return complex(scalar * cos(im), scalar * sin(im));\n}\n\ncomplex __OVERLOADABLE__ cpow(in complex base, in complex exponent)\n{\n  if (base.x == 0.0 && base.y == 0.0) return _C(0);\n\n  real re =  log(cabs(base));\n  real im =  arg(base);\n\n  real re2, im2;\n  if (exponent.y == 0.0) \n  {\n    re2 = exponent.x * re;\n    im2 = exponent.x * im;\n  }\n  else\n  {\n    re2 = (re*exponent.x) - (im*exponent.y);\n    im2 = (re*exponent.y) + (im*exponent.x);\n  }\n\n  real scalar = exp(re2);\n\n  return complex(scalar * cos(im2), scalar * sin(im2));\n  //complex temp = mul(complex(log(cabs(base)), arg(base)), exponent);\n  //real scalar = exp(temp.x);\n  //return complex(scalar * cos(temp.y), scalar * sin(temp.y));\n}\n\ncomplex __OVERLOADABLE__ cexp(in complex z) \n{\n    real scalar =  exp(z.x); // e^ix = cis x\n    return complex(scalar * cos(z.y), scalar * sin(z.y));\n}\n\n// Returns the sine of a complex number.\n//    sin(z)  =  ( exp(i*z) - exp(-i*z) ) / (2*i)\ncomplex __OVERLOADABLE__ csin(in complex z)\n{\n  //Using hyperbolic functions\n  //sin(x + iy) = sin(x) cosh(y) + i cos(x) sinh(y)\n  return complex(sin(z.x) * cosh(z.y), cos(z.x) * sinh(z.y));\n}\n\n// Returns the cosine of a complex number.\n//     cos(z)  =  ( exp(i*z) + exp(-i*z) ) / 2\ncomplex __OVERLOADABLE__ ccos(in complex z)\n{\n  //Using hyperbolic functions\n  //cos(x + iy) = cos(x) cosh(y) - i sin(x) sinh(y)\n  return complex(cos(z.x) * cosh(z.y), -sin(z.x) * sinh(z.y));\n}\n\n// Returns the tangent of a complex number.\n//     tan(z)  =  sin(z) / cos(z)\ncomplex __OVERLOADABLE__ ctan(in complex z)\n{\n  return div(csin(z), ccos(z));\n}\n\n// Returns the principal arc sine of a complex number.\n//     asin(z)  =  -i * log(i*z + sqrt(1 - z*z))\ncomplex __OVERLOADABLE__ casin(in complex z)\n{\n  complex a = sqrt(_C(1) - mul(z,z));\n  a += complex(-z.y, z.x); //z * i + a\n  a = loge(a);\n  return complex(a.y, -a.x);  // a * -i\n}\n\n// Returns the principal arc cosine of a complex number.\n//     acos(z)  =  -i * log( z + i * sqrt(1 - z*z) )\ncomplex __OVERLOADABLE__ cacos(in complex z)\n{\n  complex a = sqrt(_C(1) - mul(z,z));\n  a = z + complex(-a.y, a.x); //z + i * a\n  a = loge(a);\n  return complex(a.y, -a.x);  // a * -i\n}\n\n// Returns the principal arc tangent of a complex number.\n//     atan(z)  =  -i/2 * log( (i-z)/(i+z) )\ncomplex __OVERLOADABLE__ catan(in complex z)\n{\n  complex a = div(_I-z, _I+z);\n  return mul(_CI(-0.5), loge(a));  //-i/2 * log(a)\n}\n\ncomplex __OVERLOADABLE__ csinh(in complex z)\n{\n  //sinh(a+bi) = sinh(a) cos(b) + i(cosh(a) sin(b))\n  return complex(sinh(z.x) * cos(z.y), cosh(z.x) * sin(z.y));\n}\n\ncomplex __OVERLOADABLE__ ccosh(in complex z)\n{\n  //cosh(a+bi) = cosh(a) cos(b) + i(sinh(a) sin(b))\n  return complex(cosh(z.x) * cos(z.y), sinh(z.x) * sin(z.y));\n}\n\ncomplex __OVERLOADABLE__ ctanh(in complex z)\n{\n  //tanh(z)  =  sinh(z) / cosh(z)\n  return div(csinh(z), ccosh(z));\n}\n\n// Returns the principal inverse hyperbolic sine of a complex number.\n//     asinh(z)  =  log(z + sqrt(z*z + 1))\ncomplex __OVERLOADABLE__ casinh(in complex z)\n{\n  return loge(z + sqrt(mul(z,z) + _C(1)));\n}\n\n// Returns the principal inverse hyperbolic cosine of a complex number.\n//     acosh(z)  =  log(z + sqrt(z*z - 1))\ncomplex __OVERLOADABLE__ cacosh(in complex z)\n{\n  return loge(z + sqrt(mul(z,z) - _C(1)));\n}\n\n// Returns the principal inverse hyperbolic tangent of a complex number.\n//     atanh(z)  =  1/2 * log( (1+z)/(1-z) )\ncomplex __OVERLOADABLE__ catanh(in complex z)\n{\n  complex a = div(_I+z, _I-z);\n  return mul(_C(0.5), loge(a));\n}\n\ncomplex __OVERLOADABLE__ csqrt(in complex z)\n{\n  if (z.y == 0.0)\n  {\n    if (z.x < 0.0)\n      return complex(0.0, sqrt(-z.x));\n    else\n      return complex(sqrt(z.x), 0.0);\n  }\n  if (z.x == 0.0)\n  {\n    real r = sqrt(0.5 * abs(z.y));\n    if (z.y < 0.0) r = -r;\n    return complex(r, r);\n  }\n\n  real t = sqrt(2.0 * (cabs(z) + abs(z.x)));\n  real u = t / 2.0;\n  \n  if (z.x > 0.0)\n    return complex(u, z.y / t);\n\n  if (z.y < 0.0) u = -u;\n  return complex(abs(z.y / t), u);\n}\n\ncomplex __OVERLOADABLE__ flip(in complex z)\n{\n  return complex(z.y, z.x);\n}\n\ncomplex __OVERLOADABLE__ sqr(in complex z)\n{\n  return complex(z.x*z.x - z.y*z.y, z.x*z.y + z.y*z.x);\n}\n\ncomplex __OVERLOADABLE__ cube(in complex z)\n{\n  real x2 = z.x * z.x;\n  real y2 = z.y * z.y;\n  return complex(z.x*x2 - z.x*y2 - z.x*y2 - y2*z.x, \n                 x2*z.y + x2*z.y + z.y*x2 - y2*z.y);\n}\n\n","include/shader2d.vert":"precision highp float;\nattribute vec3 aVertexPosition;\nuniform mat4 uMVMatrix;\nvarying vec2 coord;\nvoid main(void) {\n  gl_Position = vec4(aVertexPosition, 1.0);\n  //Apply translation, rotation & scaling matrix to vertices to get fractal space coords\n  vec4 coords = uMVMatrix * vec4(aVertexPosition.xy, 0.0, 1.0);\n  coord = coords.xy;\n}\n","include/script.js":"window.steps = 10;\r\nwindow.timer = 150;\r\n\r\nwindow.step = function(count)\r\n{\r\n  var angle_inc = 2*Math.PI / (window.steps-1);\r\n  var angle = angle_inc * count;\r\n  if (angle >= 2*Math.PI) angle -= 2*Math.PI;\r\n  var x = Math.sin(angle);\r\n  var y = Math.cos(angle)-1.0;\r\n\r\n  fractal.origin.rotate = angle*180.0/Math.PI;\r\n  fractal.loadParams();\r\n  \r\n  colours.cycle(1.0 / window.steps, true);\r\n  \r\n  fractal.writeShader();\r\n  fractal.draw();\r\n  \r\n  if (count < window.steps)\r\n    setTimeout(\"window.step(\"+(count+1)+\")\", window.timer);\r\n}\r\n\r\n\r\nwindow.step(1);\r\n\r\n\r\n\r\n"};
var default_formula_list = {"base/default":{"type":"base","name":"default","label":"Default","source":"//Base parameter definitions\n//Iterations\n@iterations = int(100);\n"},"fractal/mandelbrot":{"type":"fractal","name":"mandelbrot","label":"Mandelbrot","source":"//z(n+1) = \n@znext = expression(z^p + c);\n//Power (p)\n@p = real(2);\n//Escape\n@escape = real(4);\n//Bailout Test\n@bailtest = bailout_function(norm);\n","field":null},"fractal/burning_ship":{"type":"fractal","name":"burning_ship","label":"Burning Ship","source":"//Burning ship with subtracted coord (mirrored)\n//z(n+1) = \n@znext = expression(abs(z)^p - c); \n//Power (p)\n@p = real(2);\n//Escape\n@escape = real(4);\n//Bailout Test\n@bailtest = bailout_function(norm);\n","field":null},"fractal/magnet_1":{"type":"fractal","name":"magnet_1","label":"Magnet 1","source":"//Magnet: z = ((z^b + c - 1) / (b*z + c - 2))^a\n//z(n+1) = \n@znext = expression(((z^q+c-1) / (q*z+c-2))^p);\n//Power (p)\n@p = real(2);\n//Power (q)\n@q = real(2);\n//Bailout Test\n@bailtest = bailout_function(norm);\n//Escape\n@escape = real(100);\n//Converge\n@converge = real(0.00005);\n\nconverged:\n  //Converge test\n  if (bailtest(z-(1,0)) < converge) break;\n","field":null},"fractal/magnet_2":{"type":"fractal","name":"magnet_2","label":"Magnet 2","source":"//Magnet 2: z = ((z^3 + 3z(c-1) + (c-1)(c-2)) / (3*z^2 + 3z(c-2) + (c-1)(c-2)))^a\n//z(n+1) = \n@znext = expression(((z^3 + 3.zc1 + c1c2) / (3.z^2 + 3.zc2 + c1c2 + 1))^p);\n//c1c2 =\n@c1c2 = expression((c-1).(c-2));\n//zc1 =\n@zc1 = expression(z.(c-1));\n//zc2 =\n@zc2 = expression(z.(c-2));\n//Power (p)\n@p = real(2);\n//Bailout Test\n@bailtest = bailout_function(norm);\n//Escape\n@escape = real(100);\n//Converge\n@converge = real(0.00005);\n\nconverged:\n  //Converge test\n  if (bailtest(z-(1,0)) < converge) break;\n","field":null},"fractal/magnet_3":{"type":"fractal","name":"magnet_3","label":"Magnet 3","source":"//Magnet3\n// similar to kleinien group / mobius transform arangement:\n// Mobius transorm z = az^2 + b / cz^2 + d\n\n//z(n+1) =\n@znext = expression((A*z^p+B) / (C*z^p-D) + c);\n//Power (p)\n@p = real(2);\n@A = complex(1,0);\n@B = complex(1,0);\n@C = complex(1,0);\n@D = complex(1,0);\n//Bailout Test\n@bailtest = bailout_function(norm);\n//Escape\n@escape = real(100);\n//Converge\n@converge = real(0.00005);\n\nconverged:\n  //Converge test\n  if (bailtest(z-(1,0)) < converge) break;\n","field":null},"fractal/nova":{"type":"fractal","name":"nova","label":"Nova","source":"//Nova: z = z - (relax * (z^p - 1)) / (p * z^(p-1)) + c\n//z(n+1) = \n@znext = expression(z - (relax*(z^p-1)) / (p*z^(p-1)) + c);\n//Power (p)\n@p = real(3);\n//Relax\n@relax = complex(1,0);\n//Bailout Test\n@bailtest = bailout_function(norm);\n//Converge\n@converge = real(0.00001);\n\nconverged:\n  if (bailtest(z-z_1) < converge) break;\n\n//Reset, called immediately before iterating\nreset:\n  //Nova init\n  if (!julia && !perturb) z = _C(1);\n","field":null},"fractal/cactus":{"type":"fractal","name":"cactus","label":"Cactus","source":"//z(n+1) = \n@znext = expression(z^p + z*(point-1) - point);\n//Power (p)\n@p = real(3);\n//Escape\n@escape = real(4);\n//Bailout Test\n@bailtest = bailout_function(norm);\n\n//Reset, called immediately before iterating\nreset:\n  //Reset fractal, standard doesn't work with this algorithm\n  z = point;\n  if (julia)\n    z = selected;\n  else\n    if (perturb) z = (0,0);\n\n","field":null},"fractal/phoenix":{"type":"fractal","name":"phoenix","label":"Phoenix","source":"//z(n+1) = \n@znext = expression(z^p + z^q*c + distort*z_2);\n//Power (p)\n@p = real(2);\n//Power (q)\n@q = real(0);\n//Distortion\n@distort = complex(1);\n//Escape\n@escape = real(4);\n//Bailout Test\n@bailtest = bailout_function(norm);\n\n//Reset, called immediately before iterating\nreset:\n  z = point;\n","field":null},"transform/inverse":{"type":"transform","name":"inverse","label":"Inverse","source":"//Invert the complex plane (works as pre-transform only)\n//Center\n@:center = complex(0,0);\n//Radius\n@:radius = real(1);\n\n//Init, called before setting initial conditions\ninit:\n  point = @:center + div(@:radius, (point - @:center));\n\n","field":null},"transform/functions":{"type":"transform","name":"functions","label":"Functions","source":"//Simple transform that applies a function to z\n//Function\n@:fn = complex_function(abs);\n\ntransform:\n  z = :fn(z);\n","field":null},"colour/default":{"type":"colour","name":"default","label":"Default","source":"//Default colouring algorithm\n//  Applies iteration count and repeat parameter \n//  to get a colour from the gradient palette\n\n//Palette repeat\n@:repeat = real(1);\n\nresult:\n  colour = gradient(:repeat * real(count) / real(limit));\n","field":null},"colour/smooth":{"type":"colour","name":"smooth","label":"Smooth","source":"//Smooth colouring algorithm\n//Palette repeat\n@:repeat = real(1);\n//Power\n@:power = expression(p);\n//Bailout\n@:bailout = expression(escape);\n\n//Inverse log of (power)\ncomplex :il = 1.0/loge(_C(:power));\nreal :lp = log(log(@:bailout));\n\nresult:\n  real mu = real(count) + real(mul(:lp - log(log(cabs(z))), :il));\n  colour = gradient(:repeat * mu / real(limit));\n\n","field":null},"colour/exponential_smoothing":{"type":"colour","name":"exponential_smoothing","label":"Exponential Smoothing","source":"//Exponential smoothing\n//Palette repeat\n@:repeat = real(1);\n//Divergent\n@:diverge = bool(true);\n//Convergent\n@:converge = bool(false);\n\nreal :sum = 0.0;\nreal :csum = 0.0;\n\ncalc:\n  if (:diverge)\n    :sum += exp(-cabs(z));\n\n  if (:converge)\n    :csum += exp(-1.0/cabs(z_1 - z));  \n\nresult:\n  real mu = :sum;\n  if (!:diverge || :converge && converged)\n    mu =  :csum;\n    \n  colour = gradient(:repeat * mu / real(limit));\n\n","field":null},"colour/triangle_inequality":{"type":"colour","name":"triangle_inequality","label":"Triangle Inequality","source":"//Triangle Inequality\n//Palette repeat\n@:repeat = real(1);\n//Power\n@:power = expression(p);\n//Bailout\n@:bailout = expression(escape);\n\nreal :il = 1.0/log(@:power);  //Inverse log of (power)\nreal :lp = log(log(@:bailout)/2.0);\nreal :sum = 10.0;\nreal :sum2 = 5.0;\nreal :ac = 0.0;\n\nreset:\n  :sum = 0.0;\n  :sum2 = 0.0;\n  :ac = cabs(c);\n\ncalc:\n  :sum2 = :sum;\n  if (count > 1)\n  {\n    real az2 = cabs(z - c);\n    real lowbound = abs(az2 - :ac);\n    :sum += (cabs(z) - lowbound) / (az2 + :ac - lowbound);\n  }\n\nresult:\n  :sum /= real(count);\n  :sum2 /= real(count-1);\n  real f = :il * (:lp - log(log(cabs(z))));\n  real idx = :sum2 + (:sum - :sum2) * (f+1.0);\n  colour = gradient(:repeat * idx);\n\n","field":null},"colour/orbit_traps":{"type":"colour","name":"orbit_traps","label":"Orbit Traps","source":"//Orbit traps\n\n//Palette repeat\n@:repeat = real(1);\n\nreal :closest = 1000000.0;\n\ncalc:\n  real d = cabs(z);\n  if (d < :closest) :closest = d;  \n\nresult:\n  colour = gradient(:repeat * :closest);\n","field":null},"colour/gaussian_integers":{"type":"colour","name":"gaussian_integers","label":"Gaussian Integers","source":"//Gaussian integers\n//Palette repeat\n@:repeat = real(1);\n//Mode\n@:mode = list('round|trunc|floor|ceil');\n//Colour by\n@:colourby = list('min dist|iteration @ min|angle @ min|max dist|iteration @ max|angle @ max|avg dist|min/mean/max angle|max/min ratio');\n//Normalisation\n@:normalise = list('none|point|factor|f(z)');\n//Norm factor\n@:normfact = complex(1,0);\n//Norm function\n@:normfunc = complex_function(ident);\n\nreal :r;\nreal :rmin = 1.0e12;\nreal :rmax = 0.0;\nreal :rave = 0.0;\nreal :total = 0.0;\nreal :itermin = 0.0;\nreal :itermax = 0.0;\n\ncomplex :zmin = _C(0.0);\ncomplex :zmax = _C(0.0);\ncomplex :normfac;\n\nif (:normalise == 0)\n  :normfac = _C(1.0);       //no normalisation\nif (:normalise == 1)\n  :normfac = point;        //point normalisation\nif (:normalise == 2)\n  :normfac = :normfact;    //factor normalisation\nif (:normalise == 3)\n  :normfac = :normfunc(z); //f(z) normalisation\n\ncalc:\n  //Mode = round/truncate/floor/ceiling\n  if (:mode == 0)\n    :r = cabs(z - mul(round(div(z,:normfac)), :normfac));\n  if (:mode == 1)\n    :r = cabs(z - mul(trunc(div(z,:normfac)), :normfac));\n  if (:mode == 2)\n    :r = cabs(z - mul(floor(div(z,:normfac)), :normfac));\n  if (:mode == 3)\n    :r = cabs(z - mul(ceil(div(z,:normfac)), :normfac));\n\n  :total = :total + :r;\n  :rave = :total / real(count);\n  if (:r < :rmin)\n  {\n     :rmin = :r;\n     :zmin = z;\n     :itermin = real(count+1);\n  }\n  if (:r > :rmax)\n  {\n     :rmax = :r;\n     :zmax = z;\n     :itermax = real(count+1);\n  }\n\nresult:\n  real index, t;\n  \n  // minimum distance\n  if (:colourby == 0)\n    index = :rmin;\n  // iteration @ min\n  if (:colourby == 1)\n    index = 0.01 * :itermin;\n  // angle @ min\n  if (:colourby == 2)\n  {\n    t = arg(:zmin);\n    t = t/PI;\n    if (t < 0.0) t = t + 2.0;\n    index = 0.5 * t;\n  }\n  // maximum distance  \n  if (:colourby == 3)\n    index = :rmax;\n  // iteration @ max\n  if (:colourby == 4)\n    index = 0.01 * :itermax;\n  // angle @ max\n  if (:colourby == 5)\n  {\n    t = arg(:zmax);\n    t = t/PI;\n    if (t < 0.0) t = t + 2.0;\n    index = 0.5 * t;\n  }\n  // average distance\n  if (:colourby == 6)\n    index = :rave;\n  // min/mean/max angle\n  if (:colourby == 7)\n  {\n     :zmax = complex(:rave - :rmin, :rmax - :rave);\n     t = arg(:zmax);\n     t = t/PI;\n     if (t < 0.0) t = t + 2.0;\n     index = 0.5 * t;\n  }\n  // max/min ratio\n  if (:colourby == 8)\n    index = :rmax / (:rmin + 1.e-12);\n\n  colour = gradient(:repeat * index);\n\n","field":null},"colour/hot_and_cold":{"type":"colour","name":"hot_and_cold","label":"Hot and Cold","source":"//Hot & Cold\n// 2 colors - on each orbit, the closer we are to 0, the more hot,\n// the closer we are to bailout, the more cold. Compute an average \n// over all iterations \n\n//Bailout\n@:bailout = real(4);\n//Far distance\n@:fardist = real(1.0);\n//Close distance\n@:closedist = real(0.2);\n//Hot colour\n@:hotcolour = rgba(255, 120, 5, 1.0);\n//Cold colour\n@:coldcolour = rgba(127, 200, 250, 1.0);\n\nint :closecalls = 0;\nint :farcalls = 0;\n\ncalc:\n  real dist = norm(z);\n  if (dist < @:closedist)\n    :closecalls++;\n  else if (@:bailout - dist < @:fardist)\n    :farcalls++;\n\nresult:\n  //return gradient(repeat * real(:closecalls) / real(count));\n  rgba hcolour = @:hotcolour * (real(:closecalls)/real(count));\n  rgba ccolour = @:coldcolour * (real(:farcalls)/real(count));\n  colour = rgba(hcolour.xyz + ccolour.xyz, 1.0);\n","field":null}};
