{"include/glsl-header.frag":"//GLSL specific header\nprecision highp float;\n#define GLSL\n\n#define GLSL_MAIN void main() {\n#define OPENCL_MAIN \n\n#define set_result(c) gl_FragColor = c;\n#define __OVERLOADABLE__ \n#define real float\n#define complex vec2\n#define rgba vec4\n\n//Palette lookup mu = [0,1]\n#define gradient(mu) texture2D(palette, vec2(mu, 0.0))\n\n//Uniform data\nuniform complex offset;\nuniform bool julia;\nuniform bool perturb;\nuniform real pixelsize;\nuniform complex dims;\nuniform complex origin;\nuniform complex selected;\nuniform sampler2D palette;\nuniform rgba background;\n\n//Current complex coordinate\nvarying complex coord;\n\n//GLSL only maths library prototypes\nreal __OVERLOADABLE__ log10(in real r);\nreal __OVERLOADABLE__ trunc(in real x);\nreal __OVERLOADABLE__ round(in real x);\nreal __OVERLOADABLE__ cosh(in real x);\nreal __OVERLOADABLE__ tanh(in real x);\nreal __OVERLOADABLE__ sinh(in real x);\nreal __OVERLOADABLE__ acosh(in real x);\nreal __OVERLOADABLE__ atanh(in real x);\nreal __OVERLOADABLE__ asinh(in real x);\ncomplex __OVERLOADABLE__ round(in complex z);\ncomplex __OVERLOADABLE__ trunc(in complex z);\n\n","include/opencl-header.cl":"//OpenCL specific header \n//(also need to search & replace all casts type() with c-style cast (type)() complex/real/rgba/int\n#ifdef FP64\n//Double precision\n#pragma OPENCL EXTENSION cl_khr_fp64: enable\n#pragma OPENCL EXTENSION cl_amd_fp64: enable\n#define real double\n#define complex double2\n#else\n//Single precision\n#define real float\n#define complex float2\n#endif\n\n#define OPENCL\n#define rgba float4\n#define in const\n#define discard return (rgba)(0)\n\n//Functions with alternate names\n#define mod(a,b) fmod((real)a,(real)b)\n#define abs(a) fabs(a)\n#define atan(a,b) atan2(a,b)\n\n//Palette lookup mu = [0,1]\n__constant const sampler_t sampler = CLK_NORMALIZED_COORDS_TRUE | CLK_ADDRESS_REPEAT | CLK_FILTER_NEAREST;\n#define gradient(mu) read_palette(palette, mu)\nrgba read_palette(image2d_t palette, float mu)\n{\n  uint4 p = read_imageui(palette, sampler, (float2)(mu, 0.0));\n  return (rgba)(p.x/255.0, p.y/255.0, p.z/255.0, p.w/255.0); \n}\n\n#define CALCPIXEL rgba calcpixel(complex coord, complex offset, bool julia, bool perturb, real pixelsize, complex dims, complex origin, complex selected, image2d_t palette, rgba background)\n#define GLSL_MAIN \n#define OPENCL_MAIN CALCPIXEL {\n\n#define set_result(c) return c;\nCALCPIXEL;  //Prototype\n\n//Input data\ntypedef struct __attribute__ ((packed)) Input\n{\n  real zoom;\n  real rotation;\n\n  real pixelsize;\n  complex origin;\n  complex selected;\n  rgba background;\n\n  uchar antialias;\n  uchar julia;\n  uchar perturb;\n\n  int width;\n  int height;\n} Input;\n\ncomplex rotate2d(complex v, real angle)\n{\n  const real Cos = cos(radians(angle));\n  const real Sin = sin(radians(angle));\n  return (complex)(v.x * Cos - v.y * Sin, v.x * Sin + v.y * Cos);\n}\n\n//Converts a set of pixel coords relative to element into\n// a new fractal pos based on current fractal origin, zoom & rotate...\ncomplex convert(int2 pos, int2 size, real zoom, real rotation)\n{\n   real half_w = size.x * 0.5;\n   real half_h = size.y * 0.5;\n\n   //Scale based on smallest dimension and aspect ratio\n   real box = size.x < size.y ? size.x : size.y;\n   real scalex = size.x / box;\n   real scaley = size.y / box;\n\n   real re = scalex * (pos.x - half_w) / (half_w * zoom);\n   real im = scaley * (pos.y - half_h) / (half_h * zoom);\n\n   //Apply rotation to selected point\n   return rotate2d((complex)(re, im), -rotation);\n}\n\n__kernel void fractured(__global struct Input* input, read_only image2d_t palette, write_only image2d_t output)\n{\n  int2 pos = (int2)(get_global_id(0), get_global_id(1));\n  int2 size = (int2)(input->width, input->height);\n  complex dims = (complex)(input->width, input->height);\n  complex coord = input->origin + convert(pos, size, input->zoom, input->rotation);\n\n  //Draw and blend in multiple passes for anti-aliasing\n  rgba pixel = (rgba)(0);\n  for (int j=0; j<input->antialias; j++) {\n    for (int k=0; k<input->antialias; k++) {\n      complex offset = (complex)((real)j/(real)input->antialias-0.5, (real)k/(real)input->antialias-0.5);\n      pixel += calcpixel(coord, offset, input->julia, input->perturb, input->pixelsize, \n                         dims, input->origin, input->selected, palette, input->background);\n    }\n  }\n  float aa = (float)input->antialias*(float)input->antialias;\n  pixel /= (rgba)(aa);\n  //pixel.x /= aa;\n  //pixel.y /= aa;\n  //pixel.z /= aa;\n  //pixel.w /= aa;\n  //rgba pixel = calcpixel(coord, input->antialias, input->julia, input->perturb, input->pixelsize, \n  //                       dims, input->origin, input->selected, palette, input->background);\n  write_imageui(output, (int2)(pos.x, pos.y), (uint4)(255*pixel.x,255*pixel.y,255*pixel.z,255*pixel.w));\n}\n\n","include/complex-header.frag":"//Maths library prototypes\n#define _C(x) complex(real(x),0.0)\n#define _CI(x) complex(0.0,real(x))\n#define _I complex(0.0,1.0)\n#define ident(args) args\n#define zero(args) 0\n#define czero(args) complex(0.0,0.0)\n\n#define PI  real(3.141592654)\n#define E   real(2.718281828)\nreal __OVERLOADABLE__ inv(in real r);\nreal __OVERLOADABLE__ neg(in real x);\nreal __OVERLOADABLE__ sqr(in real x);\nreal __OVERLOADABLE__ cube(in real x);\n//Complex number functions\nreal __OVERLOADABLE__ manhattan(in complex z);\nreal __OVERLOADABLE__ norm(in complex z);\nreal __OVERLOADABLE__ cabs(in real x);\nreal __OVERLOADABLE__ cabs(in complex z);\nreal __OVERLOADABLE__ arg(in complex z);\nreal __OVERLOADABLE__ imag(in complex z);\nbool __OVERLOADABLE__ equals(complex z1, complex z2, real tolerance);\ncomplex __OVERLOADABLE__ add(in complex a, in complex b);\ncomplex __OVERLOADABLE__ add(in real a, in complex b);\ncomplex __OVERLOADABLE__ add(in complex a, in real b);\ncomplex __OVERLOADABLE__ add(in real a, in real b);\ncomplex __OVERLOADABLE__ sub(in complex a, in complex b);\ncomplex __OVERLOADABLE__ sub(in real a, in complex b);\ncomplex __OVERLOADABLE__ sub(in complex a, in real b);\ncomplex __OVERLOADABLE__ sub(in real a, in real b);\ncomplex __OVERLOADABLE__ mul(in complex a, in complex b);\ncomplex __OVERLOADABLE__ mul(in real a, in complex b);\ncomplex __OVERLOADABLE__ mul(in complex a, in real b);\ncomplex __OVERLOADABLE__ mul(in real a, in real b);\ncomplex __OVERLOADABLE__ div (in complex z, in complex w);\ncomplex __OVERLOADABLE__ div(in real a, in complex b);\ncomplex __OVERLOADABLE__ div(in complex a, in real b);\ncomplex __OVERLOADABLE__ div(in real a, in real b);\ncomplex __OVERLOADABLE__ inv(in complex z);\ncomplex __OVERLOADABLE__ cpow(in real base, in real exponent);\ncomplex __OVERLOADABLE__ cpow(in real base, in complex exponent);\ncomplex __OVERLOADABLE__ cpow(in complex base, in real exponent);\ncomplex __OVERLOADABLE__ cpow(in complex base, in complex exponent);\ncomplex __OVERLOADABLE__ loge(in real r);\ncomplex __OVERLOADABLE__ loge(in complex z);\ncomplex __OVERLOADABLE__ log10(in complex z);\ncomplex __OVERLOADABLE__ cexp(in complex z);\ncomplex __OVERLOADABLE__ csin(in complex z);\ncomplex __OVERLOADABLE__ ccos(in complex z);\ncomplex __OVERLOADABLE__ ctan(in complex z);\ncomplex __OVERLOADABLE__ casin(in complex z);\ncomplex __OVERLOADABLE__ cacos(in complex z);\ncomplex __OVERLOADABLE__ catan(in complex z);\ncomplex __OVERLOADABLE__ csinh(in complex z);\ncomplex __OVERLOADABLE__ ccosh(in complex z);\ncomplex __OVERLOADABLE__ ctanh(in complex z);\ncomplex __OVERLOADABLE__ casinh(in complex z);\ncomplex __OVERLOADABLE__ cacosh(in complex z);\ncomplex __OVERLOADABLE__ catanh(in complex z);\ncomplex __OVERLOADABLE__ csqrt(in complex z);\ncomplex __OVERLOADABLE__ neg(in complex z);\ncomplex __OVERLOADABLE__ conj(in complex z);\ncomplex __OVERLOADABLE__ polar(in real r, in real theta);\ncomplex __OVERLOADABLE__ flip(in complex z);\ncomplex __OVERLOADABLE__ sqr(in complex z);\ncomplex __OVERLOADABLE__ cube(in complex z);\n\n\n","include/fractal-shader.frag":"OPENCL_MAIN\n\n---DATA---\n\nGLSL_MAIN\n\n  //Globals\n  complex z, c;\n  complex point;            //Current point coord\n  complex z_1;              //Value of z(n-1)\n  complex z_2;              //Value of z(n-2)\n  int count = 0;            //Step counter\n  bool escaped, converged;  //Bailout flags\n\n  int limit = iterations;   //Max iterations\n  rgba colour = rgba(0.0,0.0,0.0,0.0);\n\n  //Init fractal\n  point = coord + complex(offset.x*pixelsize, offset.y*pixelsize);\n\n  ---INIT---\n\n  if (julia)\n  {\n    //Julia set default\n    z = point;\n    c = selected;\n  }\n  else\n  {\n    //Mandelbrot set default\n    if (perturb) \n      z = selected; //Perturbation\n    else\n      z = (0,0);\n    c = point;\n  }\n  z_1 = z_2 = (0,0);\n\n  //Formula specific reset...\n  ---RESET---\n\n  //Iterate the fractal formula\n  //(Loop counter can only be compared to constant in GL ES 2.0)\n  for (int i=0; i < iterations; i++)\n  {\n    //Second iterations check: \"limit\" can be overridden to cut short iterations,\n    //\"iterations\" must be a constant because of lame OpenGL ES 2.0 limitations on loops\n    if (i == limit) break;\n\n    //Update z(n-2)\n    z_2 = z_1;\n    //Save current z value for z(n-1)\n    z_1 = z;\n\n    //Run next calc step\n    count = i+1;  //Current step count\n    ---PRE_TRANSFORM---\n    ---ZNEXT---\n    ---POST_TRANSFORM---\n\n    //Check bailout conditions\n    escaped = true;\n    ---ESCAPED---\n    escaped = false;\n    converged = true;\n    ---CONVERGED---\n    converged = false;\n\n    //Colour calcs...\n    ---COLOUR_CALC---\n  }\n\n  if (escaped || converged)\n  {\n    //Outside colour: normalised colour index [0,1]\n    ---OUTSIDE_COLOUR---\n  }\n  else\n  {\n    //Inside colour: normalised colour index [0,1]\n    ---INSIDE_COLOUR---\n  }\n\n  //Combine with global alpha from background colour\n  colour.w = colour.w + background.w;\n  set_result(colour);\n}\n\n","include/complex-math.frag":"//Maths functions\nreal __OVERLOADABLE__ inv(in real r)  {return 1.0/r;}\nreal __OVERLOADABLE__ neg(in real x)  {return -x;}\nreal __OVERLOADABLE__ sqr(in real x)  {return x*x;}\nreal __OVERLOADABLE__ cube(in real x) {return x*x*x;}\n\nbool __OVERLOADABLE__ equals(in complex z1, in complex z2, real tolerance)\n{\n  return distance(z1, z2) <= abs(tolerance);\n}\n\nreal __OVERLOADABLE__ manhattan(in complex z)\n{\n  return abs(z.x) + abs(z.y);\n}\n\nreal __OVERLOADABLE__ norm(in complex z)\n{\n  return dot(z,z);\n}\n\nreal __OVERLOADABLE__ cabs(in real x) {return abs(x);}\n\nreal __OVERLOADABLE__ cabs(in complex z)\n{\n  return length(z);\n}\n\nreal __OVERLOADABLE__ arg(in complex z)\n{\n  return atan(z.y,z.x);\n}\n\nreal __OVERLOADABLE__ imag(in complex z)\n{\n  return z.y;\n}\n\n#ifdef GLSL\n//Functions only required for GLSL, predefined in OpenCL\nreal __OVERLOADABLE__ log10(in real r)\n{\n  return log(r) / log(10.0);\n}\n\n//Hacks for opera to fix faulty recursive call detection\n#define RROUND(x) real(int(x + (x < 0.0 ? -0.5 : 0.5)))\n#define RTRUNC(x) real(int(x))\n\nreal __OVERLOADABLE__ trunc(in real x)\n{\n  return RTRUNC(x);\n  //return real(int(x));\n}\n\nreal __OVERLOADABLE__ round(in real x)\n{\n  return RROUND(x);\n  //return real(int(x + (x < 0.0 ? -0.5 : 0.5)));\n}\n\ncomplex __OVERLOADABLE__ round(in complex z)\n{\n  return complex(RROUND(z.x), RROUND(z.y));\n}\n\ncomplex __OVERLOADABLE__ trunc(in complex z)\n{\n  return complex(RTRUNC(z.x), RTRUNC(z.y));\n}\n\n// Hyperbolic Sine (e^x - e^-x) / 2\nreal __OVERLOADABLE__ sinh(in real x)\n{\n  real tmp = exp(x);\n  return 0.5 * (tmp - 1.0 / tmp);\n}\n\n/// Hyperbolic Cosine (e^x + e^-x) / 2\nreal __OVERLOADABLE__ cosh(in real x)\n{\n  real tmp = exp(x);\n  return 0.5 * (tmp + 1.0 / tmp);\n}\n\n// Hyperbolic Tangent (sinh / cosh)\nreal __OVERLOADABLE__ tanh(in real x)\n{\n  real tmp = exp(x);\n  real invtmp = 1.0 / tmp;\n  return (tmp - invtmp) / (tmp + invtmp);\n}\n\n// Hyperbolic arc sine log(x+sqrt(1+x^2))\nreal __OVERLOADABLE__ asinh(in real x)\n{\n  return log(x + sqrt(1.0+x*x));\n}\n\n// Hyperbolic arc cosine 2log(sqrt((x+1)/2) + sqrt((x-1)/2))\nreal __OVERLOADABLE__ acosh(in real x)\n{\n  return 2.0 * log(sqrt(0.5*x+0.5) + sqrt(0.5*x-0.5));\n}\n\n// Hyperbolic arc tangent (log (1+x) - log (1-x))/2 \nreal __OVERLOADABLE__ atanh(in real x)\n{\n  return (log(1.0+x) - log(1.0-x)) / 2.0;\n}\n#endif\n\ncomplex __OVERLOADABLE__ add(in complex a, in complex b) {return a + b;}\ncomplex __OVERLOADABLE__ add(in real a, in complex b) {return _C(a) + b;}\ncomplex __OVERLOADABLE__ add(in complex a, in real b) {return a + _C(b);}\ncomplex __OVERLOADABLE__ add(in real a, in real b)    {return _C(a + b);}\ncomplex __OVERLOADABLE__ sub(in complex a, in complex b) {return a - b;}\ncomplex __OVERLOADABLE__ sub(in real a, in complex b) {return _C(a) - b;}\ncomplex __OVERLOADABLE__ sub(in complex a, in real b) {return a - _C(b);}\ncomplex __OVERLOADABLE__ sub(in real a, in real b)    {return _C(a - b);}\n\ncomplex __OVERLOADABLE__ mul(in complex a, in complex b)\n{\n  return complex(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);\n}\n\ncomplex __OVERLOADABLE__ mul(in real a, in complex b) {return a * b;}\ncomplex __OVERLOADABLE__ mul(in complex a, in real b) {return a * b;}\ncomplex __OVERLOADABLE__ mul(in real a, in real b) {return _C(a * b);}\n\ncomplex __OVERLOADABLE__ div(in complex z, in complex w)\n{\n  //real conj = w.x*w.x + w.y*w.y;\n  //complex res = complex(z.x*w.x + z.y*w.y, z.y*w.x - z.x*w.y);\n  //return res / conj;\n  return complex(dot(z,w), z.y*w.x - z.x*w.y) / dot(w,w);\n}\n\ncomplex __OVERLOADABLE__ div(in real a, in complex z) //{return div(_C(a), z);}\n{\n  return complex(a*z.x, -a*z.y) / dot(z,z);\n}\n\ncomplex __OVERLOADABLE__ div(in complex z, in real a) //{return div(z, _C(a));}\n{\n  return complex(z.x*a, z.y*a) / (a*a);\n}\n\ncomplex __OVERLOADABLE__ div(in real a, in real b)    {return _C(a / b);}\n\ncomplex __OVERLOADABLE__ inv(in complex z)\n{\n  //1.0 / z\n  //return complex(z.x, -z.y) / dot(z,z);\n  return conj(z) / norm(z);\n}\n\ncomplex __OVERLOADABLE__ loge(in complex z)\n{\n  return complex(log(cabs(z)), arg(z));\n}\n\ncomplex __OVERLOADABLE__ log10(in complex z)\n{\n  return loge(z) / loge(_C(10));\n}\n\ncomplex __OVERLOADABLE__ loge(in real r)\n{\n  if (r < 0.0)\n    return complex(log(-r), PI);\n  else\n    return complex(log(r), 0.0);\n}\n\ncomplex __OVERLOADABLE__ neg(in complex z)\n{\n  return z * real(-1);\n}\n\ncomplex __OVERLOADABLE__ conj(in complex z)\n{\n  return complex(z.x, -z.y);\n}\n\ncomplex __OVERLOADABLE__ polar(in real r, in real theta)\n{\n  if (r < 0.0)\n  {\n    return complex(r * cos(mod(theta+PI, real(2.0*PI))), -r * sin(theta));    \n  }\n  return complex(r * cos(theta), r * sin(mod(theta, real(2.0*PI))));\n}\n\ncomplex __OVERLOADABLE__ cpow(in real base, in real exponent)\n{\n  return _C(pow(base, exponent));\n}\n\ncomplex __OVERLOADABLE__ cpow(in real base, in complex exponent)\n{\n  if (base == 0.0) return _C(0);\n  if (exponent.y == 0.0) return _C(pow(base, exponent.x));\n\n  real re = log(abs(base));\n  real im = atan(0.0, base);\n\n  real re2 = (re*exponent.x) - (im*exponent.y);\n  real im2 = (re*exponent.y) + (im*exponent.x);\n\n  real scalar =  exp(re2);\n\n  return  complex(scalar * cos(im2), scalar * sin(im2));\n}\n\ncomplex __OVERLOADABLE__ cpow(in complex base, in real exponent) \n{\n  if (base.x == 0.0 && base.y == 0.0) return _C(0);\n  if (exponent == 0.0) return _C(1);\n  if (exponent == 1.0) return base;\n  if (exponent == 2.0) return mul(base,base);\n  if (exponent == 3.0) return mul(mul(base,base),base);\n  if (base.y == 0.0) return _C(pow(base.x, exponent));\n  \n  real re = exponent * log(cabs(base));\n  real im = exponent * arg(base);\n\n  real scalar = exp(re);\n\n  return complex(scalar * cos(im), scalar * sin(im));\n}\n\ncomplex __OVERLOADABLE__ cpow(in complex base, in complex exponent)\n{\n  if (base.x == 0.0 && base.y == 0.0) return _C(0);\n\n  real re =  log(cabs(base));\n  real im =  arg(base);\n\n  real re2, im2;\n  if (exponent.y == 0.0) \n  {\n    re2 = exponent.x * re;\n    im2 = exponent.x * im;\n  }\n  else\n  {\n    re2 = (re*exponent.x) - (im*exponent.y);\n    im2 = (re*exponent.y) + (im*exponent.x);\n  }\n\n  real scalar = exp(re2);\n\n  return complex(scalar * cos(im2), scalar * sin(im2));\n  //complex temp = mul(complex(log(cabs(base)), arg(base)), exponent);\n  //real scalar = exp(temp.x);\n  //return complex(scalar * cos(temp.y), scalar * sin(temp.y));\n}\n\ncomplex __OVERLOADABLE__ cexp(in complex z) \n{\n    real scalar =  exp(z.x); // e^ix = cis x\n    return complex(scalar * cos(z.y), scalar * sin(z.y));\n}\n\n// Returns the sine of a complex number.\n//    sin(z)  =  ( exp(i*z) - exp(-i*z) ) / (2*i)\ncomplex __OVERLOADABLE__ csin(in complex z)\n{\n  //Using hyperbolic functions\n  //sin(x + iy) = sin(x) cosh(y) + i cos(x) sinh(y)\n  return complex(sin(z.x) * cosh(z.y), cos(z.x) * sinh(z.y));\n}\n\n// Returns the cosine of a complex number.\n//     cos(z)  =  ( exp(i*z) + exp(-i*z) ) / 2\ncomplex __OVERLOADABLE__ ccos(in complex z)\n{\n  //Using hyperbolic functions\n  //cos(x + iy) = cos(x) cosh(y) - i sin(x) sinh(y)\n  return complex(cos(z.x) * cosh(z.y), -sin(z.x) * sinh(z.y));\n}\n\n// Returns the tangent of a complex number.\n//     tan(z)  =  sin(z) / cos(z)\ncomplex __OVERLOADABLE__ ctan(in complex z)\n{\n  return div(csin(z), ccos(z));\n}\n\n// Returns the principal arc sine of a complex number.\n//     asin(z)  =  -i * log(i*z + sqrt(1 - z*z))\ncomplex __OVERLOADABLE__ casin(in complex z)\n{\n  complex a = sqrt(_C(1) - mul(z,z));\n  a += complex(-z.y, z.x); //z * i + a\n  a = loge(a);\n  return complex(a.y, -a.x);  // a * -i\n}\n\n// Returns the principal arc cosine of a complex number.\n//     acos(z)  =  -i * log( z + i * sqrt(1 - z*z) )\ncomplex __OVERLOADABLE__ cacos(in complex z)\n{\n  complex a = sqrt(_C(1) - mul(z,z));\n  a = z + complex(-a.y, a.x); //z + i * a\n  a = loge(a);\n  return complex(a.y, -a.x);  // a * -i\n}\n\n// Returns the principal arc tangent of a complex number.\n//     atan(z)  =  -i/2 * log( (i-z)/(i+z) )\ncomplex __OVERLOADABLE__ catan(in complex z)\n{\n  complex a = div(_I-z, _I+z);\n  return mul(_CI(-0.5), loge(a));  //-i/2 * log(a)\n}\n\ncomplex __OVERLOADABLE__ csinh(in complex z)\n{\n  //sinh(a+bi) = sinh(a) cos(b) + i(cosh(a) sin(b))\n  return complex(sinh(z.x) * cos(z.y), cosh(z.x) * sin(z.y));\n}\n\ncomplex __OVERLOADABLE__ ccosh(in complex z)\n{\n  //cosh(a+bi) = cosh(a) cos(b) + i(sinh(a) sin(b))\n  return complex(cosh(z.x) * cos(z.y), sinh(z.x) * sin(z.y));\n}\n\ncomplex __OVERLOADABLE__ ctanh(in complex z)\n{\n  //tanh(z)  =  sinh(z) / cosh(z)\n  return div(csinh(z), ccosh(z));\n}\n\n// Returns the principal inverse hyperbolic sine of a complex number.\n//     asinh(z)  =  log(z + sqrt(z*z + 1))\ncomplex __OVERLOADABLE__ casinh(in complex z)\n{\n  return loge(z + sqrt(mul(z,z) + _C(1)));\n}\n\n// Returns the principal inverse hyperbolic cosine of a complex number.\n//     acosh(z)  =  log(z + sqrt(z*z - 1))\ncomplex __OVERLOADABLE__ cacosh(in complex z)\n{\n  return loge(z + sqrt(mul(z,z) - _C(1)));\n}\n\n// Returns the principal inverse hyperbolic tangent of a complex number.\n//     atanh(z)  =  1/2 * log( (1+z)/(1-z) )\ncomplex __OVERLOADABLE__ catanh(in complex z)\n{\n  complex a = div(_I+z, _I-z);\n  return mul(_C(0.5), loge(a));\n}\n\ncomplex __OVERLOADABLE__ csqrt(in complex z)\n{\n  if (z.y == 0.0)\n  {\n    if (z.x < 0.0)\n      return complex(0.0, sqrt(-z.x));\n    else\n      return complex(sqrt(z.x), 0.0);\n  }\n  if (z.x == 0.0)\n  {\n    real r = sqrt(0.5 * abs(z.y));\n    if (z.y < 0.0) r = -r;\n    return complex(r, r);\n  }\n\n  real t = sqrt(2.0 * (cabs(z) + abs(z.x)));\n  real u = t / 2.0;\n  \n  if (z.x > 0.0)\n    return complex(u, z.y / t);\n\n  if (z.y < 0.0) u = -u;\n  return complex(abs(z.y / t), u);\n}\n\ncomplex __OVERLOADABLE__ flip(in complex z)\n{\n  return complex(z.y, z.x);\n}\n\ncomplex __OVERLOADABLE__ sqr(in complex z)\n{\n  return complex(z.x*z.x - z.y*z.y, z.x*z.y + z.y*z.x);\n}\n\ncomplex __OVERLOADABLE__ cube(in complex z)\n{\n  real x2 = z.x * z.x;\n  real y2 = z.y * z.y;\n  return complex(z.x*x2 - z.x*y2 - z.x*y2 - y2*z.x, \n                 x2*z.y + x2*z.y + z.y*x2 - y2*z.y);\n}\n\n","include/shader2d.vert":"precision highp float;\nattribute vec3 aVertexPosition;\nuniform mat4 uMVMatrix;\nvarying vec2 coord;\nvoid main(void) {\n  gl_Position = vec4(aVertexPosition, 1.0);\n  //Apply translation, rotation & scaling matrix to vertices to get fractal space coords\n  vec4 coords = uMVMatrix * vec4(aVertexPosition.xy, 0.0, 1.0);\n  coord = coords.xy;\n}\n","include/script.js":"if (this.count == 1) {\r\n  //Initialisation on the first step\r\n  this.steps = 10;\r\n  this.inc = 2*Math.PI / this.steps;\r\n}\r\n\r\nconsoleWrite(\"Animating: step \" + this.count + \"/\" + this.steps);\r\n\r\nvar angle = this.inc * this.count;\r\nif (angle >= 2*Math.PI) angle -= 2*Math.PI;\r\nvar x = Math.sin(angle);\r\nvar y = Math.cos(angle)-1.0;\r\n\r\n//Rotate\r\nfractal.origin.rotate = angle*180.0/Math.PI;\r\n//Update parameter changes to form\r\nfractal.loadParams();\r\n//Cycle the palette\r\ncolours.cycle(1.0 / this.steps, true);\r\n//Rewrite shader\r\nfractal.writeShader();\r\n//Redraw\r\nfractal.draw();\r\n"}