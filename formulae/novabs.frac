@power = real(3);    //Power
@bailout = real(0.00001);   //Bailout
@bailfunc = bailout_function(norm);   //Bailout Function
@relax = complex(1,0);  //Relax

//Reset, called once for each pixel before iterating
void reset()
{
  if (!julia && !perturb) z = C(1);  //Nova init
}

//Get next z(n+1), performs an iteration step
void runstep()
{
  //Novabs: z = abs(z - (relax * (z^p - 1)) / (p * z^(p-1))) + c
  if (power == 3.0)
  {
    complex zsquared = mul(z,z);
    complex zcubed = mul(zsquared,z);
    z = abs(z - div(mul(relax, zcubed - C(1)), mul(zsquared, C(3)))) + c;
  }
  else
  {
    //Any power - generic version, requires cpow
    z = abs(z - div(mul(relax, (cpow(z, power)) - C(1)),
               (mul(C(power), cpow(z, power-1.0))))) + c;
  }
}

bool bailed()
{
  //Check bailout condition and return true if bailed out...
  converged = true;  //Always converges
  if (bailfunc(z-zold) < bailout) return true; //Nova bailout
  return false;
}

