//Gaussian integers
//Palette repeat
@repeat = real(1);
//Round Mode
@rmode = define('round|trunc|floor|ceil');
//Colour by
@colourby = list('min dist|iteration @ min|angle @ min|max dist|iteration @ max|angle @ max|avg dist|min/mean/max angle|max/min ratio');
//Normalisation
@normalise = list('none|point|factor|f(z)');
//Norm factor
@normfact = complex(1,0);
//Norm function
@normfunc = complex_function(ident);

real @r;
real @rmin = 1.0e12;
real @rmax = 0.0;
real @rave = 0.0;
real @total = 0.0;
real @itermin = 0.0;
real @itermax = 0.0;

complex @zmin = (0,0);
complex @zmax = (0,0);
complex @normfac;

init:
  if (@normalise == 0)
    @normfac = (1,0);      //no normalisation
  if (@normalise == 1)
    @normfac = point;        //point normalisation
  if (@normalise == 2)
    @normfac = @normfact;    //factor normalisation
  if (@normalise == 3)
    @normfac = @normfunc(z); //f(z) normalisation

calc:
  //Round Mode = round/truncate/floor/ceiling
  @r = cabs(z - mul(@rmode(div(z,@normfac)), @normfac));

  @total = @total + @r;
  @rave = @total / real(count);
  if (@r < @rmin)
  {
     @rmin = @r;
     @zmin = z;
     @itermin = real(count+1);
  }
  if (@r > @rmax)
  {
     @rmax = @r;
     @zmax = z;
     @itermax = real(count+1);
  }

result:
  real index, t;
  
  // minimum distance
  if (@colourby == 0)
    index = @rmin;
  // iteration @ min
  if (@colourby == 1)
    index = 0.01 * @itermin;
  // angle @ min
  if (@colourby == 2)
  {
    t = arg(@zmin);
    t = t/PI;
    if (t < 0.0) t = t + 2.0;
    index = 0.5 * t;
  }
  // maximum distance  
  if (@colourby == 3)
    index = @rmax;
  // iteration @ max
  if (@colourby == 4)
    index = 0.01 * @itermax;
  // angle @ max
  if (@colourby == 5)
  {
    t = arg(@zmax);
    t = t/PI;
    if (t < 0.0) t = t + 2.0;
    index = 0.5 * t;
  }
  // average distance
  if (@colourby == 6)
    index = @rave;
  // min/mean/max angle
  if (@colourby == 7)
  {
     @zmax = complex(@rave - @rmin, @rmax - @rave);
     t = arg(@zmax);
     t = t/PI;
     if (t < 0.0) t = t + 2.0;
     index = 0.5 * t;
  }
  // max/min ratio
  if (@colourby == 8)
    index = @rmax / (@rmin + 1.e-12);

  colour = gradient(@repeat * index);
