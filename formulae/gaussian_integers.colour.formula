//Gaussian integers
//Palette repeat
@:repeat = real(1);
//Mode
@:mode = list('round|trunc|floor|ceil');
//Colour by
@:colourby = list('min dist|iteration @ min|angle @ min|max dist|iteration @ max|angle @ max|avg dist|min/mean/max angle|max/min ratio');
//Normalisation
@:normalise = list('none|point|factor|f(z)');
//Norm factor
@:normfact = complex(1,0);
//Norm function
@:normfunc = complex_function(ident);

real :r;
real :rmin = 1.0e12;
real :rmax = 0.0;
real :rave = 0.0;
real :total = 0.0;
real :itermin = 0.0;
real :itermax = 0.0;

complex :zmin = _C(0.0);
complex :zmax = _C(0.0);
complex :normfac;

init:
  if (:normalise == 0)
    :normfac = _C(1.0);      //no normalisation
  if (:normalise == 1)
    :normfac = point;        //point normalisation
  if (:normalise == 2)
    :normfac = :normfact;    //factor normalisation
  if (:normalise == 3)
    :normfac = :normfunc(z); //f(z) normalisation

calc:
  //Mode = round/truncate/floor/ceiling
  if (:mode == 0)
    :r = cabs(z - mul(round(div(z,:normfac)), :normfac));
  if (:mode == 1)
    :r = cabs(z - mul(trunc(div(z,:normfac)), :normfac));
  if (:mode == 2)
    :r = cabs(z - mul(floor(div(z,:normfac)), :normfac));
  if (:mode == 3)
    :r = cabs(z - mul(ceil(div(z,:normfac)), :normfac));

  :total = :total + :r;
  :rave = :total / real(count);
  if (:r < :rmin)
  {
     :rmin = :r;
     :zmin = z;
     :itermin = real(count+1);
  }
  if (:r > :rmax)
  {
     :rmax = :r;
     :zmax = z;
     :itermax = real(count+1);
  }

result:
  real index, t;
  
  // minimum distance
  if (:colourby == 0)
    index = :rmin;
  // iteration @ min
  if (:colourby == 1)
    index = 0.01 * :itermin;
  // angle @ min
  if (:colourby == 2)
  {
    t = arg(:zmin);
    t = t/PI;
    if (t < 0.0) t = t + 2.0;
    index = 0.5 * t;
  }
  // maximum distance  
  if (:colourby == 3)
    index = :rmax;
  // iteration @ max
  if (:colourby == 4)
    index = 0.01 * :itermax;
  // angle @ max
  if (:colourby == 5)
  {
    t = arg(:zmax);
    t = t/PI;
    if (t < 0.0) t = t + 2.0;
    index = 0.5 * t;
  }
  // average distance
  if (:colourby == 6)
    index = :rave;
  // min/mean/max angle
  if (:colourby == 7)
  {
     :zmax = complex(:rave - :rmin, :rmax - :rave);
     t = arg(:zmax);
     t = t/PI;
     if (t < 0.0) t = t + 2.0;
     index = 0.5 * t;
  }
  // max/min ratio
  if (:colourby == 8)
    index = :rmax / (:rmin + 1.e-12);

  colour = gradient(:repeat * index);

