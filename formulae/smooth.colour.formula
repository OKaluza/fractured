//Smooth colouring algorithm
//Type 2
@:type2 = bool(false);
//Power
@:power = expression(p);
//Bailout
@:bailout = expression(escape);

real :il, :lp;

init:
{
  //Inverse log of (power)
  :il = 1.0/log(:power);
  //Additional for Smooth 2
  :lp = log(2.0 * log(sqrt(@:bailout))) * :il;
}

#define logexp(z) log(log(cabs(z)))
//Inside version!
//#define logexp(z) loge(complex(log(cabs(z)))).x

result:
{
  real mu;
  if (:type2)
    //Smooth2 colouring
    mu = real(count) + :lp - logexp(z) * :il;
  else
    //Smooth1 colouring
    mu = real(count+1) - logexp(z) * :il;
  
  return gradient(repeat * mu / real(maxiterations));
}


