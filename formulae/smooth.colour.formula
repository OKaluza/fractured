//Smooth colouring algorithm
//Type 2
@~type2 = bool(false);
//Power
@~power = expression(p);
//Bailout
@~bailout = expression(escape);

real ~il, ~lp;

init:
{
  //Inverse log of (power)
  ~il = 1.0/log(~power);
  //Additional for Smooth 2
  ~lp = log(2.0 * log(sqrt(@~bailout))) * ~il;
}

result:
{
  real mu;
  if (~type2)
    //Smooth2 colouring
    mu = real(count) + ~lp - log(log(cabs(z))) * ~il;
  else
    //Smooth1 colouring
    mu = real(count+1) - log(log(cabs(z))) * ~il;
    
  return gradient(repeat * mu / real(maxiterations));
}


