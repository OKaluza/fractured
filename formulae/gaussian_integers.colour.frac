//Gaussian integers
@~mode = list('round|trunc|floor|ceil'); //Mode
@~colourby = list('min dist|iteration @ min|angle @ min|max dist|iteration @ max|angle @ max|avg dist|min/mean/max angle|max/min ratio'); //Colour by
@~normalise = list('none|pixel|factor|f(z)');  //Normalisation
@~normfact = complex(1,0);  //Norm factor
@~normfunc = complex_function(ident);  //Norm function

complex ~zmin, ~zmax, ~normfac;
real ~rmin, ~rmax, ~rave, ~total, ~itermin, ~itermax;

void ~init()
{
}

void ~reset()
{
  ~rmin = 1.0e12;
  ~rmax = 0.0;
  ~rave = 0.0;
  ~total = 0.0;
  ~itermin = 0.0;
  ~itermax = 0.0;

  ~zmin = C(0.0);
  ~zmax = C(0.0);

  if (~normalise == 0)
    ~normfac = C(1.0); //no normalisation
  if (~normalise == 1)
    ~normfac = pixel;  //pixel normalisation
  if (~normalise == 2)
    ~normfac = ~normfact; //factor normalisation
  if (~normalise == 3)
    ~normfac = ~normfunc(z); //f(z) normalisation
}

void ~calc()
{
  complex temp, remain;

  //Mode = round/truncate/floor/ceiling
  if (~mode == 0)
     temp = round(div(z,~normfac));
  if (~mode == 1)
     temp = trunc(div(z,~normfac));
  if (~mode == 2)
     temp = floor(div(z,~normfac));
  if (~mode == 3)
     temp = ceil(div(z,~normfac));

  remain = z - mul(temp, ~normfac);
  real r = cabs(remain);
  ~total = ~total + r;
  ~rave = ~total / real(count);
  if (r < ~rmin)
  {
     ~rmin = r;
     ~zmin = z;
     ~itermin = real(count+1);
  }
  if (r > ~rmax)
  {
     ~rmax = r;
     ~zmax = z;
     ~itermax = real(count+1);
  }
}

real ~result()
{
  real index, t;

  if (~colourby == 0)
    // minimum distance
    index = ~rmin;
  if (~colourby == 1)
    index = 0.01 * ~itermin; // iteration @ min
  if (~colourby == 2)
  {
    // angle @ min
    t = arg(~zmin);
    t = t/PI;
    if (t < 0.0) t = t + 2.0;
    index = 0.5 * t;
  }
  if (~colourby == 3)
    index = ~rmax;      // maximum distance
  if (~colourby == 4)
    index = 0.01 * ~itermax;   // iteration @ max
  if (~colourby == 5)
  {
    // angle @ max
    t = arg(~zmax);
    t = t/PI;
    if (t < 0.0) t = t + 2.0;
    index = 0.5 * t;
  }
  if (~colourby == 6)
    index = ~rave;      // average distance
  if (~colourby == 7)
  {  // min/mean/max angle
     ~zmax = complex(~rave - ~rmin, ~rmax - ~rave);
     t = arg(~zmax);
     t = t/PI;
     if (t < 0.0) t = t + 2.0;
     index = 0.5 * t;
  }
  if (~colourby == 8)
    index = ~rmax / (~rmin + 1.e-12);        // max/min ratio

  return index * real(iterations);
}

