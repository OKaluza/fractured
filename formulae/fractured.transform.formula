//Z function
@:z_fn = complex_function(ident);
//Real function
@:re_fn = real_function(abs);
//Imag function
@:im_fn = real_function(abs);
//Induct on
@:induct_on = list('|z(n-1)|z(n-2)');
//Induction
@:induct = complex(1,0);
//N (apply every)
@:N = int(1);
//Circle limit
@:circle = real(0);
//Vary Iterations
@:vary = real(0);
//Compatibility mode
@:compat = bool(true);

init:
  //Get radius in pixels
  real radius = 0.5 * dim * pixelsize;
  //Get distance from current coord to origin divided by radius
  real len = cabs(coord - origin) / radius;  

  //Variable iterations? Adjust limit
  if (:vary > 0.0)
  {
    //Vary in circle of 1/2 dim*pixelsize radius
    real d = len * :vary;
    limit = int(real(iterations) * (0.5 + d * 0.5));
  }

  //Hack for old fractals
  if (:compat) limit--;
  
reset:
  //Circle limit
  if (:circle > 0.0 && len > :circle) discard;

transform:
  //Apply every N steps
  if (:N <= 1 || mod(real(count),real(:N)) == 0.0)
  {
    //Apply induction, on z(n-1) (*) or z(n-2) (@)
    if (:induct_on > 0)
    {
      if (:induct_on == 1)
        z += mul(z_1, :induct);
      else if (:induct_on == 2)
        z += mul(z_2, :induct);
    }

    //Apply separate functions to real/imaginary components
    z = :z_fn(z);
    z = complex(:re_fn(z.x), :im_fn(z.y));

    //HACK for old fractals!
    if (:compat)  
      count++;
  }

