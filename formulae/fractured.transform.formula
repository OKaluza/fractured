//Z function
@:z_fn = complex_function(ident);
//Real function
@:re_fn = real_function(ident);
//Imag function
@:im_fn = real_function(ident);
//Induct on
@:induct_on = list('|z(n-1)|z(n-2)');
//Induction
@:induct = complex(1,0);
//N (apply every)
@:N = int(1);
//Circle limit
@:circle = real(0);
//Vary Iterations
@:vary = real(0);
//Min Iterations
@:miniter = int(50);
//Compatibility mode
@:compat = bool(true);

init:
  //Get radius in pixels of circle within largest dimension
  real radius = 0.5 * (dims.y > dims.x ? dims.y : dims.x) * pixelsize;
  //Get distance from current coord to origin divided by radius
  real len = cabs(coord - origin) / radius;  

  //Variable iterations? Adjust limit
  if (:vary > 0.0)
  {
    //Half distance to farthest corner
    real r2 = 0.5 * cabs(dims) * pixelsize;
    //Distance from current coord to origin divided by r2
    real l2 = cabs(coord - origin) / r2;  
    //Vary over [miniter,iterations] in circle
    real d = l2 * :vary;
    limit = :miniter + int(real(iterations - :miniter) * d);
    //if (limit > iterations) limit = iterations;
  }

  //Hack for old fractals (also requires iterations increased by 1)
  if (:compat) limit--;
  
reset:
  //Circle limit
  if (:circle > 0.0 && len > :circle) discard;

transform:
  //Apply every N steps
  if (:N <= 1 || mod(real(count),real(:N)) == 0.0)
  {
    //Apply induction, on z(n-1) (*) or z(n-2) (@)
    if (:induct_on > 0)
    {
      if (:induct_on == 1)
        z += mul(z_1, :induct);
      else if (:induct_on == 2)
        z += mul(z_2, :induct);
    }

    //Apply separate functions to real/imaginary components
    z = :z_fn(z);
    z = complex(:re_fn(z.x), :im_fn(z.y));
  }

  //Hack for old fractals
  if (:compat && i==limit-1) count++;

