@znext = expression((A*z^power+B) / (C*z^power-D) + c); //z(n+1) = 
@bailout = real(100);   //Bailout
@bailoutc = real(0.00005);   //Converge Bailout
@bailfunc = bailout_function(norm);   //Bailout Function
@power = real(2);    //Power
@A = complex(1,0); //A
@B = complex(1,0); //B
@C = complex(1,0); //C
@D = complex(1,0); //D

//Get next z(n+1), performs an iteration step
void runstep()
{
  //Magnet3
  // similar to kleinien group / mobius transform arangement:
  // Mobius transorm z = az^2 + b / cz^2 + d
  z = znext;
}

//Check bailout conditions and return true if bailed out
bool bailed()
{
  //Divergent bailout
  if (bailfunc(z) > bailout) return true;
  //Convergent bailout
  if (bailfunc(z - C(1)) <= bailoutc)
  {
    converged = true;
    return true;
  }
  return false;
}

