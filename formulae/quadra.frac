@bailout = real(100);   //Bailout
@bailoutc = real(0.00005);   //Converge Bailout
@bailfunc = bailout_function(norm);   //Bailout Function
@power = real(2);    //Power
@a = complex(1,0); //a
@b = complex(1,0); //b

//Init, called once at start of render
void init()
{
}

//Reset, called once for each pixel before iterating
void reset()
{
}

//Get next z(n+1), performs an iteration step
void runstep()
{
  complex z2, z3;
  z2 = mul(z,z);
  if (power == 2.0)
  {
    z3 = z2;
    z2 = z;
  }
  else 
  {
    if (power == 3.0)
      z3 = mul(z, z2);
    else
    {
      z3 = cpow(z,power);
      z2 = cpow(z,power-1.0);
    }
  }

  z = div(z3 + mul(c - a, z) - c, z2 + c - b);
}

//Check bailout conditions and return true if bailed out
bool bailed()
{
  //Divergent bailout
  if (bailfunc(z) > bailout) return true;
  //Convergent bailout
  if (bailfunc(z - C(1.0)) <= bailoutc)
  {
    converged = true;
    return true;
  }
  return false;
}

