{"include/glsl-template.frag": "//--- GLSL specific header ----------------------------------------\n#ifdef GL_ES\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n#endif\n\n#define set_result(c) gl_FragColor = c;\n#define real float\n#define complex vec2\n#define rgba vec4\n\n//Initialisers\n#define C complex\n#define R real\n//#define R(VAL) real(VAL)\n\n//Uniform data\nuniform complex offset;\nuniform int iterations;\nuniform bool julia;\nuniform real pixelsize;\nuniform complex dims;\nuniform complex origin;\nuniform complex selected_;\nuniform sampler2D palette;\nuniform rgba background;\n\nuniform real params[64];\n\ncomplex selected = selected_; //Allow transform\n\n//Palette lookup mu = [0,1]\n//#define gradient(mu) texture2D(palette, vec2(mu, 0.0))\n//Use a function as Opera fails on above define\nrgba gradient(float mu) {return texture2D(palette, vec2(mu, 0.0));}\n\n//Current complex coordinate\nvarying complex coord;\n\n//Maths Functions only required for GLSL, predefined in OpenCL\n#define PI  3.141592654\n#define E   2.718281828\n\n#define atan2(a,b) atan(a,b)\n\n//Hacks for opera to fix faulty recursive call detection\n#define round_(x) real(int(x + (x < 0.0 ? -0.5 : 0.5)))\n#define trunc_(x) real(int(x))\n\nreal trunc(in real x) {return trunc_(x); /*return real(int(x));*/}\nreal round(in real x) {return round_(x); /*return real(int(x + (x < 0.0 ? -0.5 : 0.5)));*/}\nreal log10(in real r) {return log(r) / log(10.0);}\ncomplex round(in complex z) {return complex(round_(z.x), round_(z.y));}\ncomplex trunc(in complex z) {return complex(trunc_(z.x), trunc_(z.y));}\n\n// Hyperbolic Sine (e^x - e^-x) / 2\nreal sinh(in real x)\n{\n  real tmp = exp(x);\n  return 0.5 * (tmp - 1.0 / tmp);\n}\n\n/// Hyperbolic Cosine (e^x + e^-x) / 2\nreal cosh(in real x)\n{\n  real tmp = exp(x);\n  return 0.5 * (tmp + 1.0 / tmp);\n}\n\n// Hyperbolic Tangent (sinh / cosh)\nreal tanh(in real x)\n{\n  real tmp = exp(x);\n  real invtmp = 1.0 / tmp;\n  return (tmp - invtmp) / (tmp + invtmp);\n}\n\n// Hyperbolic arc sine log(x+sqrt(1+x^2))\nreal asinh(in real x) {return log(x + sqrt(1.0+x*x));}\n// Hyperbolic arc cosine 2log(sqrt((x+1)/2) + sqrt((x-1)/2))\nreal acosh(in real x) {return 2.0 * log(sqrt(0.5*x+0.5) + sqrt(0.5*x-0.5));}\n// Hyperbolic arc tangent (log (1+x) - log (1-x))/2\nreal atanh(in real x) {return (log(1.0+x) - log(1.0-x)) / 2.0;}\n\n---LIBRARY---\n\nvoid main()\n{\n  ---CODE---\n}\n", "include/opencl-template.cl": "//--- OpenCL specific header --------------------------------------\n#ifdef FP64\n//Double precision\n#pragma OPENCL EXTENSION cl_khr_fp64: enable\n#pragma OPENCL EXTENSION cl_amd_fp64: enable\n#define real double\n#define complex double2\n#else\n//Single precision\n#define real float\n#define complex float2\n#endif\n\n#define rgba float4\n#define in const\n#define discard return (rgba)(0)\n\n//Initialisers\n#define C (complex)\n#define R (real)\n//#define C(x,y) (complex)(x,y)\n//Initialise complex,\n//really strange problem when using (complex)(x,y) (eg: for power, passed to cpow() )\n//setting components seems to work around it... (problem on NVIDIA Only)\n//complex C(in real x, in real y) { complex z; z.x = x; z.y = y; return z; }\n//#define R(x) (real)(x)\n\n//Maths functions with alternate names\n#define mod(a,b) fmod((real)a,(real)b)\n#define abs(a) fabs(a)\n#define inversesqrt(x) rsqrt(x)\n#define PI  M_PI_F\n#define E   M_E_F\n\n//Palette lookup mu = [0,1]\n__constant sampler_t sampler = CLK_NORMALIZED_COORDS_TRUE | CLK_ADDRESS_REPEAT | CLK_FILTER_NEAREST;\n#define gradient(mu) read_imagef(palette, sampler, (float2)(mu, 0.0))\n#define set_result(c) return clamp(c, 0.0f, 1.0f);\n\n---LIBRARY---\n\nrgba calcpixel(int iterations, \n               complex coord,\n               complex offset,\n               bool julia,\n               real pixelsize,\n               complex dims,\n               complex origin,\n               complex selected,\n               image2d_t palette,\n               rgba background,\n               __global real* params)\n{\n  ---CODE---\n}\n\ncomplex rotate2d(complex v, real angle)\n{\n  const real Cos = cos(radians(angle));\n  const real Sin = sin(radians(angle));\n  return (complex)(v.x * Cos - v.y * Sin, v.x * Sin + v.y * Cos);\n}\n\n//Converts a set of pixel coords relative to element into\n// a new fractal pos based on current fractal origin, zoom & rotate...\ncomplex convert(int2 pos, int2 size, real zoom, real rotation)\n{\n   real half_w = size.x * 0.5;\n   real half_h = size.y * 0.5;\n\n   //Scale based on smallest dimension and aspect ratio\n   real box = size.x < size.y ? size.x : size.y;\n   real scalex = size.x / box;\n   real scaley = size.y / box;\n\n   real re = scalex * (pos.x - half_w) / (half_w * zoom);\n   real im = scaley * (pos.y - half_h) / (half_h * zoom);\n\n   //Apply rotation to selected point\n   return rotate2d((complex)(re, im), -rotation);\n}\n\n__kernel void sample(\n    read_only image2d_t palette, \n    __global float4* temp,\n    __global real* params, \n    int antialias,\n    int julia,\n    int iterations,\n    int width,\n    int height,\n    int j, int k)\n{\n  int idx = get_global_id(1)*get_global_size(0)+get_global_id(0);\n\n  real zoom = params[0];\n  real rotation = params[1];\n  complex origin = (complex)(params[3],params[4]);\n  complex selected = (complex)(params[5],params[6]);\n  rgba background = (rgba)(params[7],params[8],params[9],params[10]);\n\n  int2 pos = (int2)(get_global_id(0), get_global_id(1));\n  int2 size = (int2)(width, height);\n  complex dims = (complex)(width, height);\n  complex coord = origin + convert(pos, size, zoom, rotation);\n\n  real pixelX = 2.0 / (zoom * width);\n  real pixelY = 2.0 / (zoom * height);\n  complex offset = (complex)(pixelX * ((real)j/(real)antialias-0.5), \n                             pixelY * ((real)k/(real)antialias-0.5));\n  rgba pixel = calcpixel(iterations, coord, offset, julia, pixelX, \n                         dims, origin, selected, palette, background, &params[11]);\n\n  //pixel = rgba(J, K, 0, 1.0);\n\n  //if (j==0 && k==0) temp[idx] = (rgba)(0);\n  temp[idx] += pixel;\n}\n\n#if 1\n__kernel void average(write_only image2d_t output, __global float4* temp, int passes)\n{\n  int2 pos = (int2)(get_global_id(0), get_global_id(1));\n  rgba pixel = temp[get_global_id(1)*get_global_size(0)+get_global_id(0)];\n  pixel /= (rgba)passes;\n  write_imagef(output, pos, pixel);\n}\n#else\n__kernel void average(__global uchar4* output, __global float4* temp, int passes)\n{\n  int idx = get_global_id(1)*get_global_size(0)+get_global_id(0);\n  output[idx] = convert_uchar4((float4)(255.0)*temp[idx]);\n  //output[idx] = convert_uchar4(255.0*temp[idx] / (rgba)(passes));\n}\n#endif\n", "include/complex.library": "//--- Maths function library --------------------------------------\n#define zero(args) 0\n#define czero(args) C(0.0,0.0)\n\nreal _inv(in real r)  {return 1.0/r;}\nreal _neg(in real x)  {return -x;}\nreal _sqr(in real x)  {return x*x;}\nreal _cube(in real x) {return x*x*x;}\n\n#define EPSILON 0.00000001\nbool equals(in complex z1, in complex z2) {return distance(z1, z2) <= EPSILON;}\nbool equalt(in complex z1, in complex z2, real tolerance) {return distance(z1, z2) <= abs(tolerance);}\n\nreal sgn(real x)             {return x / abs(x);}\nreal manhattan(in complex z) {return abs(z.x) + abs(z.y);}\nreal norm(in complex z)      {return dot(z,z); /*Norm squared*/}\nreal cabs(in complex z)      {return length(z);}\nreal arg(in complex z)       {return (z.x == 0.0 ? 0.0 : atan2(z.y,z.x));}\nreal imag(in complex z)      {return z.y;}\ncomplex conj(in complex z)   {return C(z.x, -z.y);}\n#define mul(a,b) multiply(a,b)\ncomplex multiply(in complex a, in complex b) {return C(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);}\ncomplex sqr(in complex z) {return C(z.x*z.x - z.y*z.y, z.x*z.y + z.y*z.x);}\n\ncomplex div(in complex z, in complex w)\n{\n  real d = norm(w);\n  if (d == 0.0) return C(0,0);\t//Safe version\n  return C(dot(z,w), z.y*w.x - z.x*w.y) / d;\n}\n\ncomplex inv(in complex z)\n{\n  //1.0 / z\n  real d = norm(z);\n  if (d == 0.0) return C(0,0);\t//Safe version\n  return conj(z) / d;\n}\n\nreal lnr(in real r) {return log(abs(r)); /*For colouring, return real part*/}\nreal ln(in real x)  {return log(x);}\ncomplex cln(in complex z) {return C(log(cabs(z)), arg(z));}\ncomplex clog10(in complex z) {return C(log10(cabs(z)), arg(z));}\ncomplex neg(in complex z) {return z * R(-1);}\ncomplex flip(in complex z) {return C(z.y, z.x);}\n\ncomplex polar(in real r, in real theta)\n{\n  if (r < 0.0)\n    return C(r * cos(mod(theta+PI, R(2.0*PI))), -r * sin(theta));    \n  return C(r * cos(theta), r * sin(mod(theta, R(2.0*PI))));\n}\n\ncomplex cube(in complex z)\n{\n  real x2 = z.x * z.x;\n  real y2 = z.y * z.y;\n  return C(z.x*x2 - z.x*y2 - z.x*y2 - y2*z.x, \n           x2*z.y + x2*z.y + z.y*x2 - y2*z.y);\n}\n\ncomplex cpow(in complex base, in complex exponent)\n{\n  if (base.x == 0.0 && base.y == 0.0) return C(0,0);\n  real re =  log(cabs(base));\n  real im =  arg(base);\n  real re2 = (re*exponent.x) - (im*exponent.y);\n  real im2 = (re*exponent.y) + (im*exponent.x);\n  real scalar = exp(re2);\n  return C(scalar * cos(im2), scalar * sin(im2));\n}\n\ncomplex cexp(in complex z) \n{\n  real scalar = exp(z.x); // e^ix = cis \n  return C(scalar * cos(z.y), scalar * sin(z.y));\n}\n\n#define IR2 0.707106781\ncomplex csqrt(in complex z)\n{\n  real ab = cabs(z);\n  real x = IR2 * sqrt(ab + z.x);\n  real y = IR2 * sgn(z.y) * sqrt(ab - z.x);\n  return C(x, y);\n}\n\n// Returns the sine of a complex number.  sin(z)  =  ( exp(i*z) - exp(-i*z) ) / (2*i)\n//  Using hyperbolic functions: sin(x + iy) = sin(x) cosh(y) + i cos(x) sinh(y)\ncomplex csin(in complex z) {return C(sin(z.x) * cosh(z.y), cos(z.x) * sinh(z.y));}\n\n// Returns the cosine of a complex number. cos(z)  =  ( exp(i*z) + exp(-i*z) ) / 2\n//  Using hyperbolic functions: cos(x + iy) = cos(x) cosh(y) - i sin(x) sinh(y)\ncomplex ccos(in complex z) {return C(cos(z.x) * cosh(z.y), -sin(z.x) * sinh(z.y));}\n\n// Returns the tangent of a complex number. tan(z)  =  sin(z) / cos(z)\ncomplex ctan(in complex z) {return div(csin(z), ccos(z));}\n\n// Returns the principal arc sine of a complex number. asin(z)  =  -i * log(i*z + sqrt(1 - z*z))\ncomplex casin(in complex z)\n{\n  complex a = csqrt(C(1,0) - sqr(z));\n  a += C(-z.y, z.x); //z * i + a\n  a = cln(a);\n  return C(a.y, -a.x);  // a * -i\n}\n\n// Returns the principal arc cosine of a complex number. acos(z)  =  -i * log( z + i * sqrt(1 - z*z) )\ncomplex cacos(in complex z)\n{\n  complex a = csqrt(C(1,0) - sqr(z));\n  a = z + C(-a.y, a.x); //z + i * a\n  a = cln(a);\n  return C(a.y, -a.x);  // a * -i\n}\n\n// Returns the principal arc tangent of a complex number. atan(z)  =  -i/2 * log( (i-z)/(i+z) )\ncomplex catan(in complex z)\n{\n  //complex a = div(C(0,1)-z, C(0,1)+z);\n  //return mul(C(0,-0.5), cln(a));  //-i/2 * log(a)\n  complex a = cln(div(C(0,1)-z, C(0,1)+z));\n  return C(0.5*a.y, -0.5*a.x);\n\n}\n\n//sinh(a+bi) = sinh(a) cos(b) + i(cosh(a) sin(b))\ncomplex csinh(in complex z) {return C(sinh(z.x) * cos(z.y), cosh(z.x) * sin(z.y));}\n\n//cosh(a+bi) = cosh(a) cos(b) + i(sinh(a) sin(b))\ncomplex ccosh(in complex z) {return C(cosh(z.x) * cos(z.y), sinh(z.x) * sin(z.y));}\n\n//tanh(z)  =  sinh(z) / cosh(z)\ncomplex ctanh(in complex z) {return div(csinh(z), ccosh(z));}\n\n// Returns the principal inverse hyperbolic sine of a complex number. asinh(z)  =  log(z + sqrt(z*z + 1))\ncomplex casinh(in complex z) {return cln(z + csqrt(sqr(z) + C(1,0)));}\n\n// Returns the principal inverse hyperbolic cosine of a complex number. acosh(z)  =  log(z + sqrt(z*z - 1))\ncomplex cacosh(in complex z) {return cln(z + csqrt(sqr(z) - C(1,0)));}\n\n// Returns the principal inverse hyperbolic tangent of a complex number. atanh(z)  =  1/2 * log( (1+z)/(1-z) )\ncomplex catanh(in complex z)\n{\n  //complex a = div(C(0,1)+z, C(0,1)-z);\n  //return mul(C(0.5,0), cln(a));\n  complex a = cln(div(C(0,1)+z, C(0,1)-z));\n  return C(-0.5*a.y, 0.5*a.x);\n}\n\ncomplex rotate2(complex v, real angle)\n{\n  real Cos = cos(radians(angle));\n  real Sin = sin(radians(angle));\n  return C(v.x * Cos - v.y * Sin, v.x * Sin + v.y * Cos);\n}\n\n", "include/shader2d.vert": "attribute vec3 aVertexPosition;\nuniform mat4 uMVMatrix;\nvarying vec2 coord;\nvoid main(void) {\n  gl_Position = vec4(aVertexPosition, 1.0);\n  //Apply translation, rotation & scaling matrix to vertices to get fractal space coords\n  vec4 coords = uMVMatrix * vec4(aVertexPosition.xy, 0.0, 1.0);\n  coord = coords.xy;\n}\n", "generated.source": ""}