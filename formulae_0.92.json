{"core/default": {"type": "core", "name": "default", "label": "Default", "source": "//Default formula core\nmain:\n\n  ---DATA---\n\n  //Globals\n  complex z, c;\n  complex point;            //Current point coord\n  complex z_1;              //Value of z(n-1)\n  complex z_2;              //Value of z(n-2)\n  int count = 0;            //Step counter\n  bool escaped = false;     //Bailout flags\n  bool converged = false;\n  bool perturb = false;     //Temporary: for old formulae\n\n  int limit = iterations;   //Max iterations\n  rgba colour = background;\n\n  //Init fractal\n  point = coord + offset;\n\n  ---INIT---\n\n  if (julia)\n  {\n    //Julia set default\n    z = point;\n    c = selected;\n  }\n  else\n  {\n    //Mandelbrot set default\n    z = (0,0);\n    c = point;\n  }\n  z_1 = z_2 = (0,0);\n\n  //Formula specific reset...\n  ---RESET---\n\n  //Iterate the fractal formula\n  //(Loop counter can only be compared to constant in GL ES 2.0)\n  for (int i=0; i < MAXITER; i++)\n  {\n    //Second iterations check: \"limit\" can be overridden to cut short iterations,\n    //\"iterations\" must be a constant because of lame OpenGL ES 2.0 limitations on loops\n    if (i == limit) break;\n    if (i == iterations) break; //\n\n    //Update z(n-2)\n    z_2 = z_1;\n    //Save current z value for z(n-1)\n    z_1 = z;\n\n    {\n      ---PRE_TRANSFORM---\n    }\n\n    //Run next calc step\n    count++;  //Current step count\n    ---ZNEXT---\n\n    {\n      ---POST_TRANSFORM---\n    }\n\n    //Check bailout conditions\n    ---ESCAPED---\n    ---CONVERGED---\n\n    if (escaped || converged) break;\n\n    //Colour calcs...\n    {\n      ---OUTSIDE_CALC---\n    }\n    {\n      ---INSIDE_CALC---\n    }\n  }\n\n  if (escaped || converged)\n  {\n    //Outside colour: normalised colour index [0,1]\n    ---OUTSIDE_COLOUR---\n  }\n  else\n  {\n    //Inside colour: normalised colour index [0,1]\n    ---INSIDE_COLOUR---\n  }\n\n  ---FILTER---\n\n  //Set final colour\n  set_result(colour);\n\n"}, "fractal/mandelbrot": {"type": "fractal", "name": "mandelbrot", "label": "Mandelbrot", "source": "//z(n+1) = \n@znext = expression(z^p + c);\n//Power (p)\n@p = real(2);\n//Escape\n@escape = real(4);\n//Bailout Test\n@bailtest = bailout_function(norm);\n"}, "fractal/burning_ship": {"type": "fractal", "name": "burning_ship", "label": "Burning Ship", "source": "//Burning ship\n//z(n+1) = \n@znext = expression(abs(z)^p + c); \n//Power (p)\n@p = real(2);\n//Escape\n@escape = real(4);\n//Bailout Test\n@bailtest = bailout_function(norm);\n"}, "fractal/magnet_1": {"type": "fractal", "name": "magnet_1", "label": "Magnet 1", "source": "//Magnet: z = ((z^b + c - 1) / (b*z + c - 2))^a\n//z(n+1) = \n@znext = expression(((z^q+c-1) / (q*z+c-2))^p);\n//Power (p)\n@p = real(2);\n//Power (q)\n@q = real(2);\n//Bailout Test\n@bailtest = bailout_function(norm);\n//Escape\n@escape = real(100);\n//Converge\n@converge = real(0.00005);\n//Converged\n@converged = expression(||z-1|| < converge);\n"}, "fractal/magnet_2": {"type": "fractal", "name": "magnet_2", "label": "Magnet 2", "source": "//Magnet 2: z = ((z^3 + 3z(c-1) + (c-1)(c-2)) / (3*z^2 + 3z(c-2) + (c-1)(c-2)))^a\n//z(n+1) =\n@znext = expression(((z^3 + 3z(c-1) +  (c-1)(c-2)) /\n (3z^2 + 3z(c-2) +  (c-1)(c-2) + 1)) ^ p);\n//Power (p)\n@p = real(2);\n//Bailout Test\n@bailtest = bailout_function(norm);\n//Escape\n@escape = real(100);\n//Converge\n@converge = real(0.00005);\n//Converged\n@converged = expression(||z-1|| < converge);\n"}, "fractal/magnet_3": {"type": "fractal", "name": "magnet_3", "label": "Magnet 3", "source": "//Magnet3\n//z(n+1) =\n@znext = expression((A*z^p+B) / (C*z^p-D) + c);\n//Power (p)\n@p = real(2);\n@A = complex(1,0);\n@B = complex(1,0);\n@C = complex(1,0);\n@D = complex(1,0);\n//Bailout Test\n@bailtest = bailout_function(norm);\n//Escape\n@escape = real(100);\n//Converge\n@converge = real(0.00005);\n//Converged\n@converged = expression(||z-1|| < converge);\n"}, "fractal/nova": {"type": "fractal", "name": "nova", "label": "Nova", "source": "//Nova: z = z - (relax * (z^p - 1)) / (p * z^(p-1)) + c\n//z(n+1) = \n@znext = expression(z - (relax*(z^p-1)) / (p*z^(p-1)) + c);\n//Power (p)\n@p = real(3);\n//Relax\n@relax = complex(1,0);\n//Bailout Test\n@bailtest = bailout_function(norm);\n//Converge\n@converge = real(0.00001);\n//Converged\n@converged = expression(||z-z_1|| < converge);\n\n//Reset, called immediately before iterating\nreset:\n  //Nova init\n  if (!julia) z = (1,0);\n"}, "fractal/cactus": {"type": "fractal", "name": "cactus", "label": "Cactus", "source": "//z(n+1) = \n@znext = expression(z^p + z*(point-1) - point);\n//Power (p)\n@p = real(3);\n//Escape\n@escape = real(4);\n//Bailout Test\n@bailtest = bailout_function(norm);\n\n//Reset, called immediately before iterating\nreset:\n  //Reset fractal, standard doesn't work with this algorithm\n  z = point;\n  if (julia)\n    z = selected;\n\n"}, "fractal/phoenix": {"type": "fractal", "name": "phoenix", "label": "Phoenix", "source": "//z(n+1) = \n@znext = expression(z^p + z^q*c + distort*z_2);\n//Power (p)\n@p = real(2);\n//Power (q)\n@q = real(0);\n//Distortion\n@distort = complex(0.5,0);\n//Escape\n@escape = real(4);\n//Bailout Test\n@bailtest = bailout_function(norm);\n\n//Reset, called immediately before iterating\nreset:\n  z = point;\n"}, "transform/inverse": {"type": "transform", "name": "inverse", "label": "Inverse", "source": "//Invert the complex plane\n//Center\n@center = complex(0,0);\n//Radius\n@radius = real(1);\n\n#define invert(P) P = \\@center + @radius / (P - @center)\\\n\n//Init, called before setting initial conditions\ninit:\n  invert(point);\n  invert(selected);\n\n"}, "transform/functions": {"type": "transform", "name": "functions", "label": "Functions", "source": "//Simple transform that applies a function to z\n// and/or to real / imaginary parts of z\n//Function\n@fn = complex_function();\n//Real function\n@re_fn = real_function();\n//Imag function\n@im_fn = real_function();\n\ntransform:\n  z = @fn(z);\n  z = C(@re_fn(z.x), @im_fn(z.y));\n"}, "colour/default": {"type": "colour", "name": "default", "label": "Default", "source": "//Default colouring algorithm\n//  Applies iteration count and repeat parameter \n//  to get a colour from the gradient palette\n\n//Palette repeat\n@repeat = real(1);\n\nresult:\n  colour = gradient(@repeat * R(count) / R(limit));\n"}, "colour/smooth": {"type": "colour", "name": "smooth", "label": "Smooth", "source": "//Smooth colouring algorithm\n//Palette repeat\n@repeat = real(1);\n//Power\n@power = expression(p);\n//Bailout\n@bailout = expression(escape);\n//Log function\n@lfn = real_function(log);\n\n//Inverse log of (power)\nreal @il = 1.0/@lfn(@power);\nreal @lp = @lfn(@lfn(@bailout));\n\nresult:\n  real mu = R(count) + (@lp - @lfn(@lfn(cabs(z)))) * @il;\n  //Colour from gradient \n  colour = gradient(@repeat * mu / R(limit));\n"}, "colour/exponential_smoothing": {"type": "colour", "name": "exponential_smoothing", "label": "Exponential Smoothing", "source": "//Exponential smoothing\n//Palette repeat\n@repeat = real(1);\n//Divergent\n@diverge = bool(true);\n//Convergent\n@converge = bool(false);\n//Diverge sum\n@dexp = expression(exp(-|z|));\n//Converge sum\n@cexp = expression(exp(-1/|z-z_1|));\n\nreal @sum = 0.0;\nreal @csum = 0.0;\n\ncalc:\n  if (@diverge)\n    @sum += @dexp;\n\n  if (@converge)\n    @csum += @cexp;\n\nresult:\n  real mu = @sum;\n  if (!@diverge || @converge && converged)\n    mu =  @csum;\n    \n  colour = gradient(@repeat * mu / R(limit));\n"}, "colour/triangle": {"type": "colour", "name": "triangle", "label": "Triangle", "source": "//Triangle Inequality\n//Palette repeat\n@repeat = real(1);\n//Power\n@power = expression(p);\n//Bailout\n@bailout = expression(escape);\n//Log function\n@lfn = real_function(log);\n\nreal @sum, @sum2, @ac;\n\nreset:\n  @sum = @sum2 = 0.0;\n  @ac = cabs(c);\n\ncalc:\n  @sum2 = @sum;\n  if (count > 1)\n  {\n    real az2 = cabs(z - c);\n    real lowbound = abs(az2 - @ac);\n    @sum += (cabs(z) - lowbound) / (az2 + @ac - lowbound);\n  }\n\nresult:\n  real il = 1.0/@lfn(@power);  //Inverse log of (power)\n  real lp = @lfn(@lfn(@bailout)/2.0);\n  @sum /= R(count);\n  @sum2 /= R(count-1);\n  real f = il * (lp - @lfn(@lfn(cabs(z))));\n  real idx = @sum2 + (@sum - @sum2) * (f+1.0);\n  colour = gradient(@repeat * idx);\n"}, "colour/orbit_traps": {"type": "colour", "name": "orbit_traps", "label": "Orbit Traps", "source": "//Orbit traps\n\n//Palette repeat\n@repeat = real(1);\n\nreal @closest = 1000000.0;\n\ncalc:\n  real d = cabs(z);\n  if (d < @closest) @closest = d;  \n\nresult:\n  colour = gradient(@repeat * @closest);\n"}, "colour/gaussian_integers": {"type": "colour", "name": "gaussian_integers", "label": "Gaussian Integers", "source": "//Gaussian integers\n//Palette repeat\n@repeat = real(1);\n//Round Mode\n@rmode = define('round|trunc|floor|ceil');\n//Colour by\n@colourby = list('min dist|iteration @ min|angle @ min|max dist|iteration @ max|angle @ max|avg dist|min/mean/max angle|max/min ratio');\n//Normalisation\n@normalise = list('none|point|factor|f(z)');\n//Norm factor\n@normfact = complex(1,0);\n//Norm fn\n@normfunc = complex_function();\n\nreal @rmin = 1.0e12;\nreal @rmax = 0.0;\nreal @rave = 0.0;\nreal @total = 0.0;\nreal @itermin = 0.0;\nreal @itermax = 0.0;\n\ncomplex @zmin = (0,0);\ncomplex @zmax = (0,0);\nreal @r;\n\ncomplex @factor = (1,0);\n\ninit:\n  if (@normalise == 1)\n    @factor = point;        //point normalisation\n  if (@normalise == 2)\n    @factor = @normfact;    //factor normalisation\n\ncalc:\n  //Round Mode = round/truncate/floor/ceiling\n  if (@normalise == 3)\n    @factor = @normfunc(z); //f(z) normalisation\n  \n  @r = cabs(z - mul(@rmode(div(z,@factor)), @factor));\n\n  @total = @total + @r;\n  @rave = @total / R(count);\n  if (@r < @rmin)\n  {\n     @rmin = @r;\n     @zmin = z;\n     @itermin = R(count+1);\n  }\n  if (@r > @rmax)\n  {\n     @rmax = @r;\n     @zmax = z;\n     @itermax = R(count+1);\n  }\n\nresult:\n  real index, t;\n  \n  // minimum distance\n  if (@colourby == 0)\n    index = @rmin;\n  // iteration @ min\n  if (@colourby == 1)\n    index = 0.01 * @itermin;\n  // angle @ min\n  if (@colourby == 2)\n  {\n    t = arg(@zmin);\n    t = t/PI;\n    if (t < 0.0) t = t + 2.0;\n    index = 0.5 * t;\n  }\n  // maximum distance  \n  if (@colourby == 3)\n    index = @rmax;\n  // iteration @ max\n  if (@colourby == 4)\n    index = 0.01 * @itermax;\n  // angle @ max\n  if (@colourby == 5)\n  {\n    t = arg(@zmax);\n    t = t/PI;\n    if (t < 0.0) t = t + 2.0;\n    index = 0.5 * t;\n  }\n  // average distance\n  if (@colourby == 6)\n    index = @rave;\n  // min/mean/max angle\n  if (@colourby == 7)\n  {\n     @zmax = complex(@rave - @rmin, @rmax - @rave);\n     t = arg(@zmax);\n     t = t/PI;\n     if (t < 0.0) t = t + 2.0;\n     index = 0.5 * t;\n  }\n  // max/min ratio\n  if (@colourby == 8)\n    index = @rmax / (@rmin + 1.e-12);\n\n  colour = gradient(@repeat * index);\n\n\n"}, "colour/hot_and_cold": {"type": "colour", "name": "hot_and_cold", "label": "Hot and Cold", "source": "//Hot & Cold\n// 2 colors - on each orbit, the closer we are to 0, the more hot,\n// the closer we are to bailout, the more cold. Compute an average \n// over all iterations \n\n//Bailout\n@bailout = real(4);\n//Far distance\n@fardist = real(1.5);\n//Close distance\n@closedist = real(1.0);\n//Hot colour\n@hotcolour = rgba(255, 120, 5, 1.0);\n//Cold colour\n@coldcolour = rgba(127, 200, 250, 1.0);\n\nint @closecalls = 0;\nint @farcalls = 0;\n\ncalc:\n  real dist = norm(z);\n  if (dist < @closedist)\n    @closecalls++;\n  else if (@bailout - dist < @fardist)\n    @farcalls++;\n\nresult:\n  //return gradient(repeat * R(@closecalls) / R(count));\n  rgba hcolour = @hotcolour * (R(@closecalls)/R(count));\n  rgba ccolour = @coldcolour * (R(@farcalls)/R(count));\n  colour = hcolour + ccolour;\n"}, "filter/colour_adjustment": {"type": "filter", "name": "colour_adjustment", "label": "Colour Adjustment", "source": "//Colour adjustment filter\n//Brightness\n@@brightness = range(0.0, -1.0, 1.0);\n//Contrast\n@@contrast = range(1.0, 0.0, 2.0);\n//Saturation\n@@saturation = range(1.0, 0.0, 2.0);\n\nfilter:\n  //Brightness adjust\n  real alpha = colour.w;\n  colour += float(@brightness);\n  //Saturation & Contrast adjust\n  const rgba LumCoeff = rgba(0.2125, 0.7154, 0.0721, 0.0);\n  rgba AvgLumin = rgba(0.5, 0.5, 0.5, 0.0);\n  rgba intensity = rgba(dot(colour, LumCoeff));\n  colour = mix(intensity, colour, float(@saturation));\n  colour = mix(AvgLumin, colour, float(@contrast));\n  colour.w = alpha;\n\n"}}