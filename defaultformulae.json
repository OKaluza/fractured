{"fractal/mandelbrot": {"source": "//z(n+1) = \n@znext = expression(z^p + c);\n//Power (p)\n@p = real(2);\n//Escape\n@escape = real(4);\n//Bailout Test\n@bailtest = bailout_function(norm);\n", "type": "fractal", "name": "mandelbrot", "label": "Mandelbrot"}, "fractal/burning_ship": {"source": "//Burning ship\n//z(n+1) = \n@znext = expression(abs(z)^p + c); \n//Power (p)\n@p = real(2);\n//Escape\n@escape = real(4);\n//Bailout Test\n@bailtest = bailout_function(norm);\n", "type": "fractal", "name": "burning_ship", "label": "Burning Ship"}, "fractal/magnet_1": {"source": "//Magnet: z = ((z^b + c - 1) / (b*z + c - 2))^a\n//z(n+1) = \n@znext = expression(((z^q+c-1) / (q*z+c-2))^p);\n//Power (p)\n@p = real(2);\n//Power (q)\n@q = real(2);\n//Bailout Test\n@bailtest = bailout_function(norm);\n//Escape\n@escape = real(100);\n//Converge\n@converge = real(0.00005);\n//Converged\n@converged = expression(||z-1|| < converge);\n", "type": "fractal", "name": "magnet_1", "label": "Magnet 1"}, "fractal/magnet_2": {"source": "//Magnet 2: z = ((z^3 + 3z(c-1) + (c-1)(c-2)) / (3*z^2 + 3z(c-2) + (c-1)(c-2)))^a\n//z(n+1) =\n@znext = expression(((z^3 + 3z(c-1) + \n (c-1)(c-2))\n /\n (3*z^2 + 3z(c-2) + \n (c-1)(c-2) + 1)\n) ^ p);\n//Power (p)\n@p = real(2);\n//Bailout Test\n@bailtest = bailout_function(norm);\n//Escape\n@escape = real(100);\n//Converge\n@converge = real(0.00005);\n//Converged\n@converged = expression(||z-1|| < converge);\n", "type": "fractal", "name": "magnet_2", "label": "Magnet 2"}, "fractal/magnet_3": {"source": "//Magnet3\n//z(n+1) =\n@znext = expression((A*z^p+B) / (C*z^p-D) + c);\n//Power (p)\n@p = real(2);\n@A = complex(1,0);\n@B = complex(1,0);\n@C = complex(1,0);\n@D = complex(1,0);\n//Bailout Test\n@bailtest = bailout_function(norm);\n//Escape\n@escape = real(100);\n//Converge\n@converge = real(0.00005);\n//Converged\n@converged = expression(||z-1|| < converge);\n", "type": "fractal", "name": "magnet_3", "label": "Magnet 3"}, "fractal/nova": {"source": "//Nova: z = z - (relax * (z^p - 1)) / (p * z^(p-1)) + c\n//z(n+1) = \n@znext = expression(z - (relax*(z^p-1)) / (p*z^(p-1)) + c);\n//Power (p)\n@p = real(3);\n//Relax\n@relax = complex(1,0);\n//Bailout Test\n@bailtest = bailout_function(norm);\n//Converge\n@converge = real(0.00001);\n//Converged\n@converged = expression(||z-z_1|| < converge);\n\n//Reset, called immediately before iterating\nreset:\n  //Nova init\n  if (!julia && !perturb) z = (1,0);\n", "type": "fractal", "name": "nova", "label": "Nova"}, "fractal/cactus": {"source": "//z(n+1) = \n@znext = expression(z^p + z*(point-1) - point);\n//Power (p)\n@p = real(3);\n//Escape\n@escape = real(4);\n//Bailout Test\n@bailtest = bailout_function(norm);\n\n//Reset, called immediately before iterating\nreset:\n  //Reset fractal, standard doesn't work with this algorithm\n  z = point;\n  if (julia)\n    z = selected;\n  else\n    if (perturb) z = (0,0);\n\n", "type": "fractal", "name": "cactus", "label": "Cactus"}, "fractal/phoenix": {"source": "//z(n+1) = \n@znext = expression(z^p + z^q*c + distort*z_2);\n//Power (p)\n@p = real(2);\n//Power (q)\n@q = real(0);\n//Distortion\n@distort = complex(1);\n//Escape\n@escape = real(4);\n//Bailout Test\n@bailtest = bailout_function(norm);\n\n//Reset, called immediately before iterating\nreset:\n  z = point;\n", "type": "fractal", "name": "phoenix", "label": "Phoenix"}, "transform/inverse": {"source": "//Invert the complex plane\n//Center\n@center = complex(0,0);\n//Radius\n@radius = real(1);\n\n#define invert(P) P = \\@center + @radius / (P - @center)\\\n\n//Init, called before setting initial conditions\ninit:\n  invert(point);\n  invert(selected);\n\n", "type": "transform", "name": "inverse", "label": "Inverse"}, "transform/functions": {"source": "//Simple transform that applies a function to z\n// and/or to real / imaginary parts of z\n//Function\n@fn = complex_function();\n//Real function\n@re_fn = real_function();\n//Imag function\n@im_fn = real_function();\n\ntransform:\n  z = @fn(z);\n  z = complex(@re_fn(z.x), @im_fn(z.y));\n", "type": "transform", "name": "functions", "label": "Functions"}, "colour/default": {"source": "//Default colouring algorithm\n//  Applies iteration count and repeat parameter \n//  to get a colour from the gradient palette\n\n//Palette repeat\n@repeat = real(1);\n\nresult:\n  colour = gradient(@repeat * real(count) / real(limit));\n", "type": "colour", "name": "default", "label": "Default"}, "colour/smooth": {"source": "//Smooth colouring algorithm\n//Palette repeat\n@repeat = real(1);\n//Power\n@power = expression(p);\n//Bailout\n@bailout = expression(escape);\n//Log function\n@lfn = real_function(log);\n\n//Inverse log of (power)\nreal @il = 1.0/@lfn(@power);\nreal @lp = @lfn(@lfn(@bailout));\n\nresult:\n  real mu = real(count) + (@lp - @lfn(@lfn(cabs(z)))) * @il;\n  //Colour from gradient \n  colour = gradient(@repeat * mu / real(limit));\n", "type": "colour", "name": "smooth", "label": "Smooth"}, "colour/exponential_smoothing": {"source": "//Exponential smoothing\n//Palette repeat\n@repeat = real(1);\n//Divergent\n@diverge = bool(true);\n//Convergent\n@converge = bool(false);\n//Diverge sum\n@dexp = expression(exp(-|z|));\n//Converge sum\n@cexp = expression(exp(-1/|z-z_1|));\n\nreal @sum = 0.0;\nreal @csum = 0.0;\n\ncalc:\n  if (@diverge)\n    @sum += real(@dexp);\n\n  if (@converge)\n    @csum += real(@cexp);\n\nresult:\n  real mu = @sum;\n  if (!@diverge || @converge && converged)\n    mu =  @csum;\n    \n  colour = gradient(@repeat * mu / real(limit));\n", "type": "colour", "name": "exponential_smoothing", "label": "Exponential Smoothing"}, "colour/triangle": {"source": "//Triangle Inequality\n//Palette repeat\n@repeat = real(1);\n//Power\n@power = expression(p);\n//Bailout\n@bailout = expression(escape);\n//Log function\n@lfn = real_function(log);\n\nreal @il = 1.0/@lfn(@power);  //Inverse log of (power)\nreal @lp = @lfn(@lfn(@bailout)/2.0);\nreal @sum = 10.0;\nreal @sum2 = 5.0;\nreal @ac = 0.0;\n\nreset:\n  @sum = 0.0;\n  @sum2 = 0.0;\n  @ac = cabs(c);\n\ncalc:\n  @sum2 = @sum;\n  if (count > 1)\n  {\n    real az2 = cabs(z - c);\n    real lowbound = abs(az2 - @ac);\n    @sum += (cabs(z) - lowbound) / (az2 + @ac - lowbound);\n  }\n\nresult:\n  @sum /= real(count);\n  @sum2 /= real(count-1);\n  real f = @il * (@lp - @lfn(@lfn(cabs(z))));\n  real idx = @sum2 + (@sum - @sum2) * (f+1.0);\n  colour = gradient(@repeat * idx);\n", "type": "colour", "name": "triangle", "label": "Triangle"}, "colour/orbit_traps": {"source": "//Orbit traps\n\n//Palette repeat\n@repeat = real(1);\n\nreal @closest = 1000000.0;\n\ncalc:\n  real d = cabs(z);\n  if (d < @closest) @closest = d;  \n\nresult:\n  colour = gradient(@repeat * @closest);\n", "type": "colour", "name": "orbit_traps", "label": "Orbit Traps"}, "colour/gaussian_integers": {"source": "//Gaussian integers\r\n//Palette repeat\r\n@repeat = real(1);\r\n//Round Mode\r\n@rmode = define('round|trunc|floor|ceil');\r\n//Colour by\r\n@colourby = list('min dist|iteration @ min|angle @ min|max dist|iteration @ max|angle @ max|avg dist|min/mean/max angle|max/min ratio');\r\n//Normalisation\r\n@normalise = list('none|point|factor|f(z)');\r\n//Norm factor\r\n@normfact = complex(1,0);\r\n//Norm fn\r\n@normfunc = complex_function();\r\n\r\nreal @rmin = 1.0e12;\r\nreal @rmax = 0.0;\r\nreal @rave = 0.0;\r\nreal @total = 0.0;\r\nreal @itermin = 0.0;\r\nreal @itermax = 0.0;\r\n\r\ncomplex @zmin = (0,0);\r\ncomplex @zmax = (0,0);\r\nreal @r;\r\n\r\ncomplex @factor = (1,0);\r\n\r\ninit:\r\n  if (@normalise == 1)\r\n    @factor = point;        //point normalisation\r\n  if (@normalise == 2)\r\n    @factor = @normfact;    //factor normalisation\r\n\r\ncalc:\r\n  //Round Mode = round/truncate/floor/ceiling\r\n  if (@normalise == 3)\r\n    @factor = @normfunc(z); //f(z) normalisation\r\n  \r\n  @r = cabs(z - mul(@rmode(div(z,@factor)), @factor));\r\n\r\n  @total = @total + @r;\r\n  @rave = @total / real(count);\r\n  if (@r < @rmin)\r\n  {\r\n     @rmin = @r;\r\n     @zmin = z;\r\n     @itermin = real(count+1);\r\n  }\r\n  if (@r > @rmax)\r\n  {\r\n     @rmax = @r;\r\n     @zmax = z;\r\n     @itermax = real(count+1);\r\n  }\r\n\r\nresult:\r\n  real index, t;\r\n  \r\n  // minimum distance\r\n  if (@colourby == 0)\r\n    index = @rmin;\r\n  // iteration @ min\r\n  if (@colourby == 1)\r\n    index = 0.01 * @itermin;\r\n  // angle @ min\r\n  if (@colourby == 2)\r\n  {\r\n    t = arg(@zmin);\r\n    t = t/PI;\r\n    if (t < 0.0) t = t + 2.0;\r\n    index = 0.5 * t;\r\n  }\r\n  // maximum distance  \r\n  if (@colourby == 3)\r\n    index = @rmax;\r\n  // iteration @ max\r\n  if (@colourby == 4)\r\n    index = 0.01 * @itermax;\r\n  // angle @ max\r\n  if (@colourby == 5)\r\n  {\r\n    t = arg(@zmax);\r\n    t = t/PI;\r\n    if (t < 0.0) t = t + 2.0;\r\n    index = 0.5 * t;\r\n  }\r\n  // average distance\r\n  if (@colourby == 6)\r\n    index = @rave;\r\n  // min/mean/max angle\r\n  if (@colourby == 7)\r\n  {\r\n     @zmax = complex(@rave - @rmin, @rmax - @rave);\r\n     t = arg(@zmax);\r\n     t = t/PI;\r\n     if (t < 0.0) t = t + 2.0;\r\n     index = 0.5 * t;\r\n  }\r\n  // max/min ratio\r\n  if (@colourby == 8)\r\n    index = @rmax / (@rmin + 1.e-12);\r\n\r\n  colour = gradient(@repeat * index);\r\n\r\n\r\n", "type": "colour", "name": "gaussian_integers", "label": "Gaussian Integers"}, "colour/hot_and_cold": {"source": "//Hot & Cold\n// 2 colors - on each orbit, the closer we are to 0, the more hot,\n// the closer we are to bailout, the more cold. Compute an average \n// over all iterations \n\n//Bailout\n@bailout = real(4);\n//Far distance\n@fardist = real(1.5);\n//Close distance\n@closedist = real(1.0);\n//Hot colour\n@hotcolour = rgba(255, 120, 5, 1.0);\n//Cold colour\n@coldcolour = rgba(127, 200, 250, 1.0);\n\nint @closecalls = 0;\nint @farcalls = 0;\n\ncalc:\n  real dist = norm(z);\n  if (dist < @closedist)\n    @closecalls++;\n  else if (@bailout - dist < @fardist)\n    @farcalls++;\n\nresult:\n  //return gradient(repeat * real(@closecalls) / real(count));\n  rgba hcolour = @hotcolour * (real(@closecalls)/real(count));\n  rgba ccolour = @coldcolour * (real(@farcalls)/real(count));\n  colour = hcolour + ccolour;\n", "type": "colour", "name": "hot_and_cold", "label": "Hot and Cold"}, "filter/colour_adjustment": {"source": "//Colour adjustment filter\n//Brightness\n@@brightness = range(0.0, -1.0, 1.0);\n//Contrast\n@@contrast = range(1.0, 0.0, 2.0);\n//Saturation\n@@saturation = range(1.0, 0.0, 2.0);\n\nfilter:\n  //Brightness adjust\n  colour += @brightness;\n  //Saturation & Contrast adjust\n  const rgba LumCoeff = rgba(0.2125, 0.7154, 0.0721, 0);\n  rgba AvgLumin = rgba(0.5, 0.5, 0.5, 0.0);\n  rgba intensity = rgba(dot(colour, LumCoeff));\n  colour = mix(intensity, colour, @saturation);\n  colour = mix(AvgLumin, colour, @contrast);\n\n", "type": "filter", "name": "colour_adjustment", "label": "Colour Adjustment"}}