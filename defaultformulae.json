{"base/default": {"source": "//Base parameter definitions\n//Iterations\n@iterations = int(100);\n", "type": "base", "name": "default", "label": "Default"}, "fractal/mandelbrot": {"source": "//z(n+1) = \n@znext = expression(z^p + c);\n//Power (p)\n@p = real(2);\n//Escape\n@escape = real(4);\n//Bailout Test\n@bailtest = bailout_function(norm);\n", "type": "fractal", "name": "mandelbrot", "label": "Mandelbrot"}, "fractal/burning_ship": {"source": "//Burning ship with subtracted coord (mirrored)\n//z(n+1) = \n@znext = expression(abs(z)^p - c); \n//Power (p)\n@p = real(2);\n//Escape\n@escape = real(4);\n//Bailout Test\n@bailtest = bailout_function(norm);\n", "type": "fractal", "name": "burning_ship", "label": "Burning Ship"}, "fractal/magnet_1": {"source": "//Magnet: z = ((z^b + c - 1) / (b*z + c - 2))^a\n//z(n+1) = \n@znext = expression(((z^q+c-1) / (q*z+c-2))^p);\n//Power (p)\n@p = real(2);\n//Power (q)\n@q = real(2);\n//Bailout Test\n@bailtest = bailout_function(norm);\n//Escape\n@escape = real(100);\n//Converge\n@converge = real(0.00005);\n\nconverged:\n  //Converge test\n  converged = (bailtest(z-(1,0)) < converge);\n", "type": "fractal", "name": "magnet_1", "label": "Magnet 1"}, "fractal/magnet_2": {"source": "//Magnet 2: z = ((z^3 + 3z(c-1) + (c-1)(c-2)) / (3*z^2 + 3z(c-2) + (c-1)(c-2)))^a\n//z(n+1) =\n@znext = expression(((z^3 + 3(c-1).z + \n (c-1)(c-2))\n /\n (3.z^2 + 3(c-2).z + \n (c-1)(c-2) + 1)\n) ^ p);\n//Power (p)\n@p = real(2);\n//Bailout Test\n@bailtest = bailout_function(norm);\n//Escape\n@escape = real(100);\n//Converge\n@converge = real(0.00005);\n\nconverged:\n  //Converge test\n  converged = (bailtest(z-(1,0)) < converge);\n\n", "type": "fractal", "name": "magnet_2", "label": "Magnet 2"}, "fractal/magnet_3": {"source": "//Magnet3\n//z(n+1) =\n@znext = expression((A*z^p+B) / (C*z^p-D) + c);\n//Power (p)\n@p = real(2);\n@A = complex(1,0);\n@B = complex(1,0);\n@C = complex(1,0);\n@D = complex(1,0);\n//Bailout Test\n@bailtest = bailout_function(norm);\n//Escape\n@escape = real(100);\n//Converge\n@converge = real(0.00005);\n\nconverged:\n  //Converge test\n  converged = (bailtest(z-(1,0)) < converge);\n", "type": "fractal", "name": "magnet_3", "label": "Magnet 3"}, "fractal/nova": {"source": "//Nova: z = z - (relax * (z^p - 1)) / (p * z^(p-1)) + c\n//z(n+1) = \n@znext = expression(z - (relax*(z^p-1)) / (p*z^(p-1)) + c);\n//Power (p)\n@p = real(3);\n//Relax\n@relax = complex(1,0);\n//Bailout Test\n@bailtest = bailout_function(norm);\n//Converge\n@converge = real(0.00001);\n\nconverged:\n  converged = (bailtest(z-z_1) < converge);\n\n//Reset, called immediately before iterating\nreset:\n  //Nova init\n  if (!julia && !perturb) z = (1,0);\n", "type": "fractal", "name": "nova", "label": "Nova"}, "fractal/cactus": {"source": "//z(n+1) = \n@znext = expression(z^p + z*(point-1) - point);\n//Power (p)\n@p = real(3);\n//Escape\n@escape = real(4);\n//Bailout Test\n@bailtest = bailout_function(norm);\n\n//Reset, called immediately before iterating\nreset:\n  //Reset fractal, standard doesn't work with this algorithm\n  z = point;\n  if (julia)\n    z = selected;\n  else\n    if (perturb) z = (0,0);\n\n", "type": "fractal", "name": "cactus", "label": "Cactus"}, "fractal/phoenix": {"source": "//z(n+1) = \n@znext = expression(z^p + z^q*c + distort*z_2);\n//Power (p)\n@p = real(2);\n//Power (q)\n@q = real(0);\n//Distortion\n@distort = complex(1);\n//Escape\n@escape = real(4);\n//Bailout Test\n@bailtest = bailout_function(norm);\n\n//Reset, called immediately before iterating\nreset:\n  z = point;\n", "type": "fractal", "name": "phoenix", "label": "Phoenix"}, "transform/inverse": {"source": "//Invert the complex plane\n//Center\n@:center = complex(0,0);\n//Radius\n@:radius = real(1);\n\n#define invert(P) P = @:center + div(@:radius, (P - @:center))\n\n//Init, called before setting initial conditions\ninit:\n  invert(point);\n  invert(selected);\n\n", "type": "transform", "name": "inverse", "label": "Inverse"}, "transform/functions": {"source": "//Simple transform that applies a function to z\n//Function\n@:fn = complex_function(abs);\n\ntransform:\n  z = :fn(z);\n", "type": "transform", "name": "functions", "label": "Functions"}, "colour/default": {"source": "//Default colouring algorithm\n//  Applies iteration count and repeat parameter \n//  to get a colour from the gradient palette\n\n//Palette repeat\n@:repeat = real(1);\n\nresult:\n  colour = gradient(:repeat * real(count) / real(limit));\n", "type": "colour", "name": "default", "label": "Default"}, "colour/smooth": {"source": "//Smooth colouring algorithm\n//Palette repeat\n@:repeat = real(1);\n//Power\n@:power = expression(p);\n//Bailout\n@:bailout = expression(escape);\n//Log function\n@:lfn = real_function(log);\n\n//Inverse log of (power)\nreal :il = 1.0/:lfn(:power);\nreal :lp = :lfn(:lfn(@:bailout));\n\nresult:\n  real mu = real(count) + (:lp - :lfn(:lfn(cabs(z)))) * :il;\n  colour = gradient(:repeat * mu / real(limit));\n\n", "type": "colour", "name": "smooth", "label": "Smooth"}, "colour/exponential_smoothing": {"source": "//Exponential smoothing\n//Palette repeat\n@:repeat = real(1);\n//Divergent\n@:diverge = bool(true);\n//Convergent\n@:converge = bool(false);\n\nreal :sum = 0.0;\nreal :csum = 0.0;\n\ncalc:\n  if (:diverge)\n    :sum += exp(-cabs(z));\n\n  if (:converge)\n    :csum += exp(-1.0/cabs(z_1 - z));  \n\nresult:\n  real mu = :sum;\n  if (!:diverge || :converge && converged)\n    mu =  :csum;\n    \n  colour = gradient(:repeat * mu / real(limit));\n\n", "type": "colour", "name": "exponential_smoothing", "label": "Exponential Smoothing"}, "colour/triangle_inequality": {"source": "//Triangle Inequality\n//Palette repeat\n@:repeat = real(1);\n//Power\n@:power = expression(p);\n//Bailout\n@:bailout = expression(escape);\n//Log function\n@:lfn = real_function(log);\n\nreal :il = 1.0/:lfn(@:power);  //Inverse log of (power)\nreal :lp = :lfn(:lfn(@:bailout)/2.0);\nreal :sum = 10.0;\nreal :sum2 = 5.0;\nreal :ac = 0.0;\n\nreset:\n  :sum = 0.0;\n  :sum2 = 0.0;\n  :ac = cabs(c);\n\ncalc:\n  :sum2 = :sum;\n  if (count > 1)\n  {\n    real az2 = cabs(z - c);\n    real lowbound = abs(az2 - :ac);\n    :sum += (cabs(z) - lowbound) / (az2 + :ac - lowbound);\n  }\n\nresult:\n  :sum /= real(count);\n  :sum2 /= real(count-1);\n  real f = :il * (:lp - :lfn(:lfn(cabs(z))));\n  real idx = :sum2 + (:sum - :sum2) * (f+1.0);\n  colour = gradient(:repeat * idx);\n\n", "type": "colour", "name": "triangle_inequality", "label": "Triangle Inequality"}, "colour/orbit_traps": {"source": "//Orbit traps\n\n//Palette repeat\n@:repeat = real(1);\n\nreal :closest = 1000000.0;\n\ncalc:\n  real d = cabs(z);\n  if (d < :closest) :closest = d;  \n\nresult:\n  colour = gradient(:repeat * :closest);\n", "type": "colour", "name": "orbit_traps", "label": "Orbit Traps"}, "colour/gaussian_integers": {"source": "//Gaussian integers\n//Palette repeat\n@:repeat = real(1);\n//Round Mode\n@:rmode = define('round|trunc|floor|ceil');\n//Colour by\n@:colourby = list('min dist|iteration @ min|angle @ min|max dist|iteration @ max|angle @ max|avg dist|min/mean/max angle|max/min ratio');\n//Normalisation\n@:normalise = list('none|point|factor|f(z)');\n//Norm factor\n@:normfact = complex(1,0);\n//Norm function\n@:normfunc = complex_function(ident);\n\nreal :r;\nreal :rmin = 1.0e12;\nreal :rmax = 0.0;\nreal :rave = 0.0;\nreal :total = 0.0;\nreal :itermin = 0.0;\nreal :itermax = 0.0;\n\ncomplex :zmin = (0,0);\ncomplex :zmax = (0,0);\ncomplex :normfac;\n\ninit:\n  if (:normalise == 0)\n    :normfac = (1,0);      //no normalisation\n  if (:normalise == 1)\n    :normfac = point;        //point normalisation\n  if (:normalise == 2)\n    :normfac = :normfact;    //factor normalisation\n  if (:normalise == 3)\n    :normfac = :normfunc(z); //f(z) normalisation\n\ncalc:\n  //Round Mode = round/truncate/floor/ceiling\n  :r = cabs(z - mul(:rmode(div(z,:normfac)), :normfac));\n\n  :total = :total + :r;\n  :rave = :total / real(count);\n  if (:r < :rmin)\n  {\n     :rmin = :r;\n     :zmin = z;\n     :itermin = real(count+1);\n  }\n  if (:r > :rmax)\n  {\n     :rmax = :r;\n     :zmax = z;\n     :itermax = real(count+1);\n  }\n\nresult:\n  real index, t;\n  \n  // minimum distance\n  if (:colourby == 0)\n    index = :rmin;\n  // iteration @ min\n  if (:colourby == 1)\n    index = 0.01 * :itermin;\n  // angle @ min\n  if (:colourby == 2)\n  {\n    t = arg(:zmin);\n    t = t/PI;\n    if (t < 0.0) t = t + 2.0;\n    index = 0.5 * t;\n  }\n  // maximum distance  \n  if (:colourby == 3)\n    index = :rmax;\n  // iteration @ max\n  if (:colourby == 4)\n    index = 0.01 * :itermax;\n  // angle @ max\n  if (:colourby == 5)\n  {\n    t = arg(:zmax);\n    t = t/PI;\n    if (t < 0.0) t = t + 2.0;\n    index = 0.5 * t;\n  }\n  // average distance\n  if (:colourby == 6)\n    index = :rave;\n  // min/mean/max angle\n  if (:colourby == 7)\n  {\n     :zmax = complex(:rave - :rmin, :rmax - :rave);\n     t = arg(:zmax);\n     t = t/PI;\n     if (t < 0.0) t = t + 2.0;\n     index = 0.5 * t;\n  }\n  // max/min ratio\n  if (:colourby == 8)\n    index = :rmax / (:rmin + 1.e-12);\n\n  colour = gradient(:repeat * index);\n\n", "type": "colour", "name": "gaussian_integers", "label": "Gaussian Integers"}, "colour/hot_and_cold": {"source": "//Hot & Cold\n// 2 colors - on each orbit, the closer we are to 0, the more hot,\n// the closer we are to bailout, the more cold. Compute an average \n// over all iterations \n\n//Bailout\n@:bailout = real(4);\n//Far distance\n@:fardist = real(1.5);\n//Close distance\n@:closedist = real(1.0);\n//Hot colour\n@:hotcolour = rgba(255, 120, 5, 1.0);\n//Cold colour\n@:coldcolour = rgba(127, 200, 250, 1.0);\n\nint :closecalls = 0;\nint :farcalls = 0;\n\ncalc:\n  real dist = norm(z);\n  if (dist < @:closedist)\n    :closecalls++;\n  else if (@:bailout - dist < @:fardist)\n    :farcalls++;\n\nresult:\n  //return gradient(repeat * real(:closecalls) / real(count));\n  rgba hcolour = @:hotcolour * (real(:closecalls)/real(count));\n  rgba ccolour = @:coldcolour * (real(:farcalls)/real(count));\n  colour = hcolour + ccolour;\n", "type": "colour", "name": "hot_and_cold", "label": "Hot and Cold"}}